!> This is the central module for the SIS2 sea ice model.	!> This is the central module for the SIS2 sea ice model.
module ice_model_mod						module ice_model_mod

! This file is a part of SIS2. See LICENSE.md for the license	! This file is a part of SIS2. See LICENSE.md for the license

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!   SIS2 is a SEA ICE MODEL for coupling through the GFDL exc	!   SIS2 is a SEA ICE MODEL for coupling through the GFDL exc
! is a revision of the original SIS with have extended capabi	! is a revision of the original SIS with have extended capabi
! the option of using a B-grid or C-grid spatial discretizati	! the option of using a B-grid or C-grid spatial discretizati
! software has been extensively reformulated from SIS for gre	! software has been extensively reformulated from SIS for gre
! with the Modular Ocean Model, version 6 (MOM6), and to perm	! with the Modular Ocean Model, version 6 (MOM6), and to perm
! dynamical coupling between the ocean and sea-ice.          	! dynamical coupling between the ocean and sea-ice.          
!   This module manages fluxes between sub-modules, many diag	!   This module manages fluxes between sub-modules, many diag
! overall time stepping of the sea ice. Sea ice dynamics are 	! overall time stepping of the sea ice. Sea ice dynamics are 
! ice_dyn_bgrid.F90 or ice_dyn_cgrid.F90, while the transport	! ice_dyn_bgrid.F90 or ice_dyn_cgrid.F90, while the transport
! and tracers occurs in ice_transport.F90.  Sea ice thermodyn	! and tracers occurs in ice_transport.F90.  Sea ice thermodyn
! in ice_thm.F90 and other modules that are subsequently call	! in ice_thm.F90 and other modules that are subsequently call
! The Lagrangian icebergs code of Adcroft and Martin is calle	! The Lagrangian icebergs code of Adcroft and Martin is calle
!   The original SIS was developed by Mike Winton (Michael.Wi	!   The original SIS was developed by Mike Winton (Michael.Wi
! SIS2 has been developed by Robert Hallberg and Mike Winton,	! SIS2 has been developed by Robert Hallberg and Mike Winton,
! contributions from many people at NOAA/GFDL, including Alis	! contributions from many people at NOAA/GFDL, including Alis
! Niki Zadeh.                                                	! Niki Zadeh.                                                
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

use MOM_cpu_clock,     only : cpu_clock_id, cpu_clock_begin, 	use MOM_cpu_clock,     only : cpu_clock_id, cpu_clock_begin, 
use MOM_cpu_clock,     only : CLOCK_COMPONENT, CLOCK_SUBCOMPO	use MOM_cpu_clock,     only : CLOCK_COMPONENT, CLOCK_SUBCOMPO
use MOM_domains,       only : MOM_domain_type			use MOM_domains,       only : MOM_domain_type
use MOM_domains,       only : pass_var, pass_vector, AGRID, B	use MOM_domains,       only : pass_var, pass_vector, AGRID, B
use MOM_domains,       only : fill_symmetric_edges, MOM_domai	use MOM_domains,       only : fill_symmetric_edges, MOM_domai
use MOM_dyn_horgrid,   only : dyn_horgrid_type, create_dyn_ho	use MOM_dyn_horgrid,   only : dyn_horgrid_type, create_dyn_ho
use MOM_error_handler, only : SIS_error=>MOM_error, FATAL, WA	use MOM_error_handler, only : SIS_error=>MOM_error, FATAL, WA
use MOM_error_handler, only : callTree_enter, callTree_leave,	use MOM_error_handler, only : callTree_enter, callTree_leave,
use MOM_file_parser,   only : get_param, log_param, log_versi	use MOM_file_parser,   only : get_param, log_param, log_versi
use MOM_file_parser,   only : open_param_file, close_param_fi	use MOM_file_parser,   only : open_param_file, close_param_fi
use MOM_hor_index,     only : hor_index_type, hor_index_init	use MOM_hor_index,     only : hor_index_type, hor_index_init
use MOM_io,            only : file_exists			use MOM_io,            only : file_exists
use MOM_obsolete_params, only : obsolete_logical, obsolete_re	use MOM_obsolete_params, only : obsolete_logical, obsolete_re
use MOM_string_functions, only : uppercase			use MOM_string_functions, only : uppercase
use MOM_time_manager,  only : time_type, time_type_to_real, r	use MOM_time_manager,  only : time_type, time_type_to_real, r
use MOM_time_manager,  only : operator(+), operator(-)		use MOM_time_manager,  only : operator(+), operator(-)
use MOM_time_manager,  only : operator(>), operator(*), opera	use MOM_time_manager,  only : operator(>), operator(*), opera
use MOM_unit_scaling,  only : unit_scale_type, unit_scaling_i	use MOM_unit_scaling,  only : unit_scale_type, unit_scaling_i
use MOM_unit_scaling,  only : unit_scaling_end, fix_restart_u	use MOM_unit_scaling,  only : unit_scaling_end, fix_restart_u

use astronomy_mod, only : astronomy_init, astronomy_end		use astronomy_mod, only : astronomy_init, astronomy_end
use astronomy_mod, only : universal_time, orbital_time, diurn	use astronomy_mod, only : universal_time, orbital_time, diurn
use ocean_albedo_mod, only : compute_ocean_albedo            	use ocean_albedo_mod, only : compute_ocean_albedo            
use ocean_rough_mod,  only : compute_ocean_roughness         	use ocean_rough_mod,  only : compute_ocean_roughness         

use ice_bergs,          only : icebergs, icebergs_run, iceber	use ice_bergs,          only : icebergs, icebergs_run, iceber
use ice_boundary_types, only : ocean_ice_boundary_type, atmos	use ice_boundary_types, only : ocean_ice_boundary_type, atmos
use ice_boundary_types, only : ocn_ice_bnd_type_chksum, atm_i	use ice_boundary_types, only : ocn_ice_bnd_type_chksum, atm_i
use ice_boundary_types, only : lnd_ice_bnd_type_chksum		use ice_boundary_types, only : lnd_ice_bnd_type_chksum
use ice_grid,           only : set_ice_grid, ice_grid_end, ic	use ice_grid,           only : set_ice_grid, ice_grid_end, ic
use ice_spec_mod,       only : get_sea_surface			use ice_spec_mod,       only : get_sea_surface
use ice_type_mod,       only : ice_data_type, dealloc_ice_arr	use ice_type_mod,       only : ice_data_type, dealloc_ice_arr
use ice_type_mod,       only : ice_type_slow_reg_restarts, ic	use ice_type_mod,       only : ice_type_slow_reg_restarts, ic
use ice_type_mod,       only : Ice_public_type_chksum, Ice_pu	use ice_type_mod,       only : Ice_public_type_chksum, Ice_pu
use ice_type_mod,       only : ice_model_restart, ice_stock_p	use ice_type_mod,       only : ice_model_restart, ice_stock_p

use SIS_ctrl_types,    only : SIS_slow_CS, SIS_fast_CS		use SIS_ctrl_types,    only : SIS_slow_CS, SIS_fast_CS
use SIS_ctrl_types,    only : ice_diagnostics_init, ice_diags	use SIS_ctrl_types,    only : ice_diagnostics_init, ice_diags
use SIS_debugging,     only : chksum, uvchksum, Bchksum, SIS_	use SIS_debugging,     only : chksum, uvchksum, Bchksum, SIS_
use SIS_diag_mediator, only : set_SIS_axes_info, SIS_diag_med	use SIS_diag_mediator, only : set_SIS_axes_info, SIS_diag_med
use SIS_diag_mediator, only : enable_SIS_averaging, disable_S	use SIS_diag_mediator, only : enable_SIS_averaging, disable_S
use SIS_diag_mediator, only : post_SIS_data, post_data=>post_	use SIS_diag_mediator, only : post_SIS_data, post_data=>post_
use SIS_dyn_trans,     only : SIS_dynamics_trans, SIS_multi_d	use SIS_dyn_trans,     only : SIS_dynamics_trans, SIS_multi_d
use SIS_dyn_trans,     only : slab_ice_dyn_trans		use SIS_dyn_trans,     only : slab_ice_dyn_trans
use SIS_dyn_trans,     only : SIS_dyn_trans_register_restarts	use SIS_dyn_trans,     only : SIS_dyn_trans_register_restarts
use SIS_dyn_trans,     only : SIS_dyn_trans_read_alt_restarts	use SIS_dyn_trans,     only : SIS_dyn_trans_read_alt_restarts
use SIS_dyn_trans,     only : SIS_dyn_trans_transport_CS, SIS	use SIS_dyn_trans,     only : SIS_dyn_trans_transport_CS, SIS
use SIS_fast_thermo,   only : accumulate_deposition_fluxes, c	use SIS_fast_thermo,   only : accumulate_deposition_fluxes, c
use SIS_fast_thermo,   only : do_update_ice_model_fast, avg_t	use SIS_fast_thermo,   only : do_update_ice_model_fast, avg_t
use SIS_fast_thermo,   only : redo_update_ice_model_fast, fin	use SIS_fast_thermo,   only : redo_update_ice_model_fast, fin
use SIS_fast_thermo,   only : infill_array, SIS_fast_thermo_i	use SIS_fast_thermo,   only : infill_array, SIS_fast_thermo_i
use SIS_framework,     only : set_domain, nullify_domain, bro	use SIS_framework,     only : set_domain, nullify_domain, bro
use SIS_restart,       only : restore_SIS_state, query_initia	use SIS_restart,       only : restore_SIS_state, query_initia
use SIS_restart,       only : determine_is_new_run, is_new_ru	use SIS_restart,       only : determine_is_new_run, is_new_ru
use SIS_framework,     only : coupler_1d_bc_type, coupler_2d_	use SIS_framework,     only : coupler_1d_bc_type, coupler_2d_
use SIS_framework,     only : coupler_type_spawn, coupler_typ	use SIS_framework,     only : coupler_type_spawn, coupler_typ
use SIS_framework,     only : coupler_type_rescale_data, coup	use SIS_framework,     only : coupler_type_rescale_data, coup
use SIS_fixed_initialization, only : SIS_initialize_fixed	use SIS_fixed_initialization, only : SIS_initialize_fixed
use SIS_get_input,     only : Get_SIS_input, directories	use SIS_get_input,     only : Get_SIS_input, directories
use SIS_hor_grid,      only : SIS_hor_grid_type, set_hor_grid	use SIS_hor_grid,      only : SIS_hor_grid_type, set_hor_grid
use SIS_open_boundary, only : ice_OBC_type			use SIS_open_boundary, only : ice_OBC_type
use SIS_optics,        only : ice_optics_SIS2, SIS_optics_ini	use SIS_optics,        only : ice_optics_SIS2, SIS_optics_ini
use SIS_optics,        only : VIS_DIR, VIS_DIF, NIR_DIR, NIR_	use SIS_optics,        only : VIS_DIR, VIS_DIF, NIR_DIR, NIR_
use SIS_slow_thermo,   only : slow_thermodynamics, SIS_slow_t	use SIS_slow_thermo,   only : slow_thermodynamics, SIS_slow_t
use SIS_slow_thermo,   only : SIS_slow_thermo_set_ptrs		use SIS_slow_thermo,   only : SIS_slow_thermo_set_ptrs
use SIS_state_initialization, only : read_archaic_thermo_rest	use SIS_state_initialization, only : read_archaic_thermo_rest
use SIS_state_initialization, only : ice_state_mass_init, ice	use SIS_state_initialization, only : ice_state_mass_init, ice
use SIS_sum_output,    only : SIS_sum_output_init,  write_ice	use SIS_sum_output,    only : SIS_sum_output_init,  write_ice
use SIS_tracer_flow_control, only : SIS_call_tracer_register,	use SIS_tracer_flow_control, only : SIS_call_tracer_register,
use SIS_tracer_flow_control, only : SIS_tracer_flow_control_e	use SIS_tracer_flow_control, only : SIS_tracer_flow_control_e
use SIS_tracer_registry, only : register_SIS_tracer, register	use SIS_tracer_registry, only : register_SIS_tracer, register
use SIS_transcribe_grid, only : copy_dyngrid_to_SIS_horgrid, 	use SIS_transcribe_grid, only : copy_dyngrid_to_SIS_horgrid, 
use SIS_transport,     only : adjust_ice_categories		use SIS_transport,     only : adjust_ice_categories
use SIS_types,         only : ice_ocean_flux_type, alloc_ice_	use SIS_types,         only : ice_ocean_flux_type, alloc_ice_
use SIS_types,         only : ocean_sfc_state_type, alloc_oce	use SIS_types,         only : ocean_sfc_state_type, alloc_oce
use SIS_types,         only : fast_ice_avg_type, alloc_fast_i	use SIS_types,         only : fast_ice_avg_type, alloc_fast_i
use SIS_types,         only : total_sfc_flux_type, alloc_tota	use SIS_types,         only : total_sfc_flux_type, alloc_tota
use SIS_types,         only : ice_rad_type, ice_rad_register_	use SIS_types,         only : ice_rad_type, ice_rad_register_
use SIS_types,         only : simple_OSS_type, alloc_simple_O	use SIS_types,         only : simple_OSS_type, alloc_simple_O
use SIS_types,         only : ice_state_type, alloc_IST_array	use SIS_types,         only : ice_state_type, alloc_IST_array
use SIS_types,         only : IST_chksum, IST_bounds_check, i	use SIS_types,         only : IST_chksum, IST_bounds_check, i
use SIS_types,         only : ice_state_read_alt_restarts, re	use SIS_types,         only : ice_state_read_alt_restarts, re
use SIS_types,         only : register_unit_conversion_restar	use SIS_types,         only : register_unit_conversion_restar
use SIS_types,         only : rescale_fast_to_slow_restart_fi	use SIS_types,         only : rescale_fast_to_slow_restart_fi
use SIS_types,         only : copy_IST_to_IST, copy_FIA_to_FI	use SIS_types,         only : copy_IST_to_IST, copy_FIA_to_FI
use SIS_types,         only : copy_TSF_to_TSF, redistribute_T	use SIS_types,         only : copy_TSF_to_TSF, redistribute_T
use SIS_types,         only : copy_Rad_to_Rad, redistribute_R	use SIS_types,         only : copy_Rad_to_Rad, redistribute_R
use SIS_types,         only : redistribute_IST_to_IST, redist	use SIS_types,         only : redistribute_IST_to_IST, redist
use SIS_types,         only : redistribute_sOSS_to_sOSS, FIA_	use SIS_types,         only : redistribute_sOSS_to_sOSS, FIA_
use SIS_utils,         only : post_avg, ice_grid_chksum		use SIS_utils,         only : post_avg, ice_grid_chksum
use SIS2_ice_thm,      only : ice_temp_SIS2, SIS2_ice_thm_ini	use SIS2_ice_thm,      only : ice_temp_SIS2, SIS2_ice_thm_ini
use SIS2_ice_thm,      only : ice_thermo_init, ice_thermo_end	use SIS2_ice_thm,      only : ice_thermo_init, ice_thermo_end
use specified_ice,     only : specified_ice_dynamics, specifi	use specified_ice,     only : specified_ice_dynamics, specifi
use specified_ice,     only : specified_ice_end, specified_ic	use specified_ice,     only : specified_ice_end, specified_ic

implicit none ; private						implicit none ; private

#include <SIS2_memory.h>					#include <SIS2_memory.h>

public :: ice_data_type, ocean_ice_boundary_type, atmos_ice_b	public :: ice_data_type, ocean_ice_boundary_type, atmos_ice_b
public :: ice_model_init, share_ice_domains, ice_model_end, i	public :: ice_model_init, share_ice_domains, ice_model_end, i
public :: update_ice_model_fast					public :: update_ice_model_fast
public :: ice_model_restart  ! for intermediate restarts	public :: ice_model_restart  ! for intermediate restarts
public :: ocn_ice_bnd_type_chksum, atm_ice_bnd_type_chksum	public :: ocn_ice_bnd_type_chksum, atm_ice_bnd_type_chksum
public :: lnd_ice_bnd_type_chksum, ice_data_type_chksum		public :: lnd_ice_bnd_type_chksum, ice_data_type_chksum
public :: update_ice_atm_deposition_flux			public :: update_ice_atm_deposition_flux
public :: unpack_ocean_ice_boundary, exchange_slow_to_fast_ic	public :: unpack_ocean_ice_boundary, exchange_slow_to_fast_ic
public :: ice_model_fast_cleanup, unpack_land_ice_boundary	public :: ice_model_fast_cleanup, unpack_land_ice_boundary
public :: exchange_fast_to_slow_ice, update_ice_model_slow	public :: exchange_fast_to_slow_ice, update_ice_model_slow
public :: update_ice_slow_thermo, update_ice_dynamics_trans	public :: update_ice_slow_thermo, update_ice_dynamics_trans
public :: unpack_ocn_ice_bdry				      <

!>@{ CPU time clock IDs						!>@{ CPU time clock IDs
integer :: iceClock						integer :: iceClock
integer :: ice_clock_slow, ice_clock_fast, ice_clock_exchange	integer :: ice_clock_slow, ice_clock_fast, ice_clock_exchange
!!@}								!!@}

integer, parameter :: REDIST=2 !< Redistribute for exchange	integer, parameter :: REDIST=2 !< Redistribute for exchange
integer, parameter :: DIRECT=3 !< Use direct exchange		integer, parameter :: DIRECT=3 !< Use direct exchange

contains							contains


!------------------------------------------------------------	!------------------------------------------------------------
!> Update the sea-ice state due to slow processes, including 	!> Update the sea-ice state due to slow processes, including 
!! freezing and melting, precipitation, and transport.		!! freezing and melting, precipitation, and transport.
subroutine update_ice_model_slow(Ice)				subroutine update_ice_model_slow(Ice)
  type(ice_data_type), intent(inout) :: Ice !< The publicly v	  type(ice_data_type), intent(inout) :: Ice !< The publicly v

  call update_ice_slow_thermo(Ice)				  call update_ice_slow_thermo(Ice)

  call update_ice_dynamics_trans(Ice)				  call update_ice_dynamics_trans(Ice)

end subroutine update_ice_model_slow				end subroutine update_ice_model_slow


!------------------------------------------------------------	!------------------------------------------------------------
!> Update the sea-ice state due to slow thermodynamic process	!> Update the sea-ice state due to slow thermodynamic process
!! freezing and melting, precipitation, and brine drainage, a	!! freezing and melting, precipitation, and brine drainage, a
!! also the accumulated effects of faster thermodynamic proce	!! also the accumulated effects of faster thermodynamic proce
subroutine update_ice_slow_thermo(Ice)				subroutine update_ice_slow_thermo(Ice)
  type(ice_data_type), intent(inout) :: Ice !< The publicly v	  type(ice_data_type), intent(inout) :: Ice !< The publicly v

  ! These pointers are used to simplify the code below.		  ! These pointers are used to simplify the code below.
  type(ice_grid_type),     pointer :: sIG => NULL()		  type(ice_grid_type),     pointer :: sIG => NULL()
  type(SIS_hor_grid_type), pointer :: sG => NULL()		  type(SIS_hor_grid_type), pointer :: sG => NULL()
  type(ice_state_type),    pointer :: sIST => NULL()		  type(ice_state_type),    pointer :: sIST => NULL()
  type(fast_ice_avg_type), pointer :: FIA => NULL()		  type(fast_ice_avg_type), pointer :: FIA => NULL()
  type(ice_rad_type),      pointer :: Rad => NULL()		  type(ice_rad_type),      pointer :: Rad => NULL()
  type(unit_scale_type),   pointer :: US => NULL()		  type(unit_scale_type),   pointer :: US => NULL()
  real :: dt_slow  ! The time step over which to advance the 	  real :: dt_slow  ! The time step over which to advance the 
  integer :: i, j, i2, j2, i_off, j_off				  integer :: i, j, i2, j2, i_off, j_off

  if (.not.associated(Ice%sCS)) call SIS_error(FATAL, &		  if (.not.associated(Ice%sCS)) call SIS_error(FATAL, &
      "The pointer to Ice%sCS must be associated in update_ic	      "The pointer to Ice%sCS must be associated in update_ic

  sIST => Ice%sCS%IST ; sIG => Ice%sCS%IG ; sG => Ice%sCS%G ;	  sIST => Ice%sCS%IST ; sIG => Ice%sCS%IG ; sG => Ice%sCS%G ;
  Rad => Ice%sCS%Rad ; US => Ice%sCS%US				  Rad => Ice%sCS%Rad ; US => Ice%sCS%US
  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c	  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c

  ! Advance the slow PE clock to give the end time of the slo	  ! Advance the slow PE clock to give the end time of the slo
  ! is a separate clock inside the fCS that is advanced elsew	  ! is a separate clock inside the fCS that is advanced elsew
  Ice%sCS%Time = Ice%sCS%Time + Ice%sCS%Time_step_slow		  Ice%sCS%Time = Ice%sCS%Time + Ice%sCS%Time_step_slow
  if (.not.associated(Ice%fCS)) then				  if (.not.associated(Ice%fCS)) then
    Ice%Time = Ice%sCS%Time					    Ice%Time = Ice%sCS%Time
  endif								  endif
  dt_slow = US%s_to_T*time_type_to_real(Ice%sCS%Time_step_slo	  dt_slow = US%s_to_T*time_type_to_real(Ice%sCS%Time_step_slo

  if (Ice%sCS%debug) then					  if (Ice%sCS%debug) then
    call Ice_public_type_chksum("Start update_ice_slow_thermo	    call Ice_public_type_chksum("Start update_ice_slow_thermo
    call FIA_chksum("Start update_ice_slow_thermo", FIA, sG, 	    call FIA_chksum("Start update_ice_slow_thermo", FIA, sG, 
    ! call IOF_chksum("Start update_ice_slow_thermo", Ice%sCS	    ! call IOF_chksum("Start update_ice_slow_thermo", Ice%sCS
  endif								  endif

  ! Store some diagnostic fluxes...				  ! Store some diagnostic fluxes...
  !$OMP parallel do default(none) shared(sG, FIA)		  !$OMP parallel do default(none) shared(sG, FIA)
  do j=sG%jsc,sG%jec ; do i=sG%isc,sG%iec			  do j=sG%jsc,sG%jec ; do i=sG%isc,sG%iec
    FIA%calving_preberg(i,j) = FIA%calving(i,j)			    FIA%calving_preberg(i,j) = FIA%calving(i,j)
    FIA%calving_hflx_preberg(i,j) = FIA%calving_hflx(i,j)	    FIA%calving_hflx_preberg(i,j) = FIA%calving_hflx(i,j)
  enddo ; enddo							  enddo ; enddo

  if (Ice%sCS%redo_fast_update) then				  if (Ice%sCS%redo_fast_update) then
    call redo_update_ice_model_fast(sIST, Ice%sCS%sOSS, Ice%s	    call redo_update_ice_model_fast(sIST, Ice%sCS%sOSS, Ice%s
              Ice%sCS%optics_CSp, Ice%sCS%Time_step_slow, Ice	              Ice%sCS%optics_CSp, Ice%sCS%Time_step_slow, Ice

    call find_excess_fluxes(FIA, Ice%sCS%TSF, Ice%sCS%XSF, sI	    call find_excess_fluxes(FIA, Ice%sCS%TSF, Ice%sCS%XSF, sI
  endif								  endif

  call convert_frost_to_snow(FIA, sG, US, sIG)			  call convert_frost_to_snow(FIA, sG, US, sIG)

  if (Ice%sCS%do_icebergs) then					  if (Ice%sCS%do_icebergs) then
    if (Ice%sCS%berg_windstress_bug) then			    if (Ice%sCS%berg_windstress_bug) then
      ! This code is only required to reproduce an old bug.	      ! This code is only required to reproduce an old bug.
      i_off = LBOUND(Ice%flux_t,1) - sG%isc			      i_off = LBOUND(Ice%flux_t,1) - sG%isc
      j_off = LBOUND(Ice%flux_t,2) - sG%jsc			      j_off = LBOUND(Ice%flux_t,2) - sG%jsc
      !$OMP parallel do default(none) shared(Ice,sG,US,i_off,	      !$OMP parallel do default(none) shared(Ice,sG,US,i_off,
      do j=sG%jsc,sG%jec ; do i=sG%isc,sG%iec			      do j=sG%jsc,sG%jec ; do i=sG%isc,sG%iec
        i2 = i+i_off ; j2 = j+j_off				        i2 = i+i_off ; j2 = j+j_off
        Ice%sCS%IOF%flux_u_ocn(i,j) = US%kg_m2s_to_RZ_T*US%m_	        Ice%sCS%IOF%flux_u_ocn(i,j) = US%kg_m2s_to_RZ_T*US%m_
        Ice%sCS%IOF%flux_v_ocn(i,j) = US%kg_m2s_to_RZ_T*US%m_	        Ice%sCS%IOF%flux_v_ocn(i,j) = US%kg_m2s_to_RZ_T*US%m_
      enddo ; enddo						      enddo ; enddo
    endif							    endif

    call cpu_clock_end(ice_clock_slow) ; call cpu_clock_end(i	    call cpu_clock_end(ice_clock_slow) ; call cpu_clock_end(i
    call update_icebergs(sIST, Ice%sCS%OSS, Ice%sCS%IOF, FIA,	    call update_icebergs(sIST, Ice%sCS%OSS, Ice%sCS%IOF, FIA,
                         sG, US, sIG, Ice%sCS%dyn_trans_CSp)	                         sG, US, sIG, Ice%sCS%dyn_trans_CSp)
    call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice	    call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice

    if (Ice%sCS%debug) then					    if (Ice%sCS%debug) then
      call FIA_chksum("After update_icebergs", FIA, sG, US)	      call FIA_chksum("After update_icebergs", FIA, sG, US)
    endif							    endif
  endif								  endif

  if (Ice%sCS%debug) then					  if (Ice%sCS%debug) then
    call Ice_public_type_chksum("Before slow_thermodynamics",	    call Ice_public_type_chksum("Before slow_thermodynamics",
    call FIA_chksum("Before slow_thermodynamics", FIA, sG, US	    call FIA_chksum("Before slow_thermodynamics", FIA, sG, US
    call IST_chksum("Before slow_thermodynamics", sIST, sG, U	    call IST_chksum("Before slow_thermodynamics", sIST, sG, U
    call OSS_chksum("Before slow_thermodynamics", Ice%sCS%OSS	    call OSS_chksum("Before slow_thermodynamics", Ice%sCS%OSS
    if (associated(Ice%sCS%XSF)) &				    if (associated(Ice%sCS%XSF)) &
      call TSF_chksum("Before slow_thermodynamics XSF", Ice%s	      call TSF_chksum("Before slow_thermodynamics XSF", Ice%s
    ! call IOF_chksum("Before slow_thermodynamics", Ice%sCS%I	    ! call IOF_chksum("Before slow_thermodynamics", Ice%sCS%I
  endif								  endif

  call slow_thermodynamics(sIST, dt_slow, Ice%sCS%slow_thermo	  call slow_thermodynamics(sIST, dt_slow, Ice%sCS%slow_thermo
                           Ice%sCS%XSF, Ice%sCS%IOF, sG, US, 	                           Ice%sCS%XSF, Ice%sCS%IOF, sG, US, 
  if (Ice%sCS%debug) then					  if (Ice%sCS%debug) then
    call Ice_public_type_chksum("Before set_ocean_top_fluxes"	    call Ice_public_type_chksum("Before set_ocean_top_fluxes"
    call IOF_chksum("Before set_ocean_top_fluxes", Ice%sCS%IO	    call IOF_chksum("Before set_ocean_top_fluxes", Ice%sCS%IO
    call IST_chksum("Before set_ocean_top_fluxes", sIST, sG, 	    call IST_chksum("Before set_ocean_top_fluxes", sIST, sG, 
  endif								  endif
  ! Set up the thermodynamic fluxes in the externally visible	  ! Set up the thermodynamic fluxes in the externally visible
  call set_ocean_top_fluxes(Ice, sIST, Ice%sCS%IOF, FIA, Ice%	  call set_ocean_top_fluxes(Ice, sIST, Ice%sCS%IOF, FIA, Ice%

  call cpu_clock_end(ice_clock_slow) ; call cpu_clock_end(ice	  call cpu_clock_end(ice_clock_slow) ; call cpu_clock_end(ice

end subroutine update_ice_slow_thermo				end subroutine update_ice_slow_thermo

!------------------------------------------------------------	!------------------------------------------------------------
!> Update the sea-ice state due to dynamics and ice transport	!> Update the sea-ice state due to dynamics and ice transport
subroutine update_ice_dynamics_trans(Ice, time_step, start_cy	subroutine update_ice_dynamics_trans(Ice, time_step, start_cy
  type(ice_data_type),       intent(inout) :: Ice !< The publ	  type(ice_data_type),       intent(inout) :: Ice !< The publ
  type(time_type), optional, intent(in)    :: time_step !< Th	  type(time_type), optional, intent(in)    :: time_step !< Th
  logical,         optional, intent(in)    :: start_cycle !< 	  logical,         optional, intent(in)    :: start_cycle !< 
                                                  !! treated 	                                                  !! treated 
                                                  !! in a tim	                                                  !! in a tim
  logical,         optional, intent(in)    :: end_cycle   !< 	  logical,         optional, intent(in)    :: end_cycle   !< 
                                                  !! treated 	                                                  !! treated 
                                                  !! in a tim	                                                  !! in a tim
  real,            optional, intent(in)    :: cycle_length !<	  real,            optional, intent(in)    :: cycle_length !<

  ! These pointers are used to simplify the code below.		  ! These pointers are used to simplify the code below.
  type(ice_grid_type),     pointer :: sIG => NULL()		  type(ice_grid_type),     pointer :: sIG => NULL()
  type(SIS_hor_grid_type), pointer :: sG => NULL()		  type(SIS_hor_grid_type), pointer :: sG => NULL()
  type(ice_state_type),    pointer :: sIST => NULL()		  type(ice_state_type),    pointer :: sIST => NULL()
  type(fast_ice_avg_type), pointer :: FIA => NULL()		  type(fast_ice_avg_type), pointer :: FIA => NULL()
  type(unit_scale_type),   pointer :: US => NULL()		  type(unit_scale_type),   pointer :: US => NULL()
  real :: dt_slow  ! The time step over which to advance the 	  real :: dt_slow  ! The time step over which to advance the 
  logical :: do_multi_trans, cycle_start			  logical :: do_multi_trans, cycle_start

  if (.not.associated(Ice%sCS)) call SIS_error(FATAL, &		  if (.not.associated(Ice%sCS)) call SIS_error(FATAL, &
      "The pointer to Ice%sCS must be associated in update_ic	      "The pointer to Ice%sCS must be associated in update_ic

  sIST => Ice%sCS%IST ; sIG => Ice%sCS%IG ; sG => Ice%sCS%G ;	  sIST => Ice%sCS%IST ; sIG => Ice%sCS%IG ; sG => Ice%sCS%G ;
  dt_slow = US%s_to_T*time_type_to_real(Ice%sCS%Time_step_slo	  dt_slow = US%s_to_T*time_type_to_real(Ice%sCS%Time_step_slo
  if (present(time_step)) dt_slow = US%s_to_T*time_type_to_re	  if (present(time_step)) dt_slow = US%s_to_T*time_type_to_re
  cycle_start = .true. ; if (present(start_cycle)) cycle_star	  cycle_start = .true. ; if (present(start_cycle)) cycle_star

  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c	  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c

  ! Do halo updates on the forcing fields, as necessary.  Thi	  ! Do halo updates on the forcing fields, as necessary.  Thi
  ! the call to SIS_dynamics_trans, because update_icebergs d	  ! the call to SIS_dynamics_trans, because update_icebergs d
  ! updates, and slow_thermodynamics only works on the comput	  ! updates, and slow_thermodynamics only works on the comput
  if (cycle_start) then						  if (cycle_start) then
    call pass_vector(FIA%WindStr_x, FIA%WindStr_y, sG%Domain,	    call pass_vector(FIA%WindStr_x, FIA%WindStr_y, sG%Domain,
    call pass_vector(FIA%WindStr_ocn_x, FIA%WindStr_ocn_y, sG	    call pass_vector(FIA%WindStr_ocn_x, FIA%WindStr_ocn_y, sG
    call pass_var(FIA%ice_cover, sG%Domain, complete=.false.)	    call pass_var(FIA%ice_cover, sG%Domain, complete=.false.)
    call pass_var(FIA%ice_free,  sG%Domain, complete=.true.)	    call pass_var(FIA%ice_free,  sG%Domain, complete=.true.)
  endif								  endif
  if (sIST%valid_IST) then					  if (sIST%valid_IST) then
    call pass_var(sIST%part_size, sG%Domain)			    call pass_var(sIST%part_size, sG%Domain)
    call pass_var(sIST%mH_ice, sG%Domain, complete=.false.)	    call pass_var(sIST%mH_ice, sG%Domain, complete=.false.)
    call pass_var(sIST%mH_pond, sG%Domain, complete=.false.)	    call pass_var(sIST%mH_pond, sG%Domain, complete=.false.)
    call pass_var(sIST%mH_snow, sG%Domain, complete=.true.)	    call pass_var(sIST%mH_snow, sG%Domain, complete=.true.)
  endif								  endif

  if (Ice%sCS%debug) then					  if (Ice%sCS%debug) then
    call Ice_public_type_chksum("Before SIS_dynamics_trans", 	    call Ice_public_type_chksum("Before SIS_dynamics_trans", 
  endif								  endif

  do_multi_trans = (present(start_cycle) .or. present(end_cyc	  do_multi_trans = (present(start_cycle) .or. present(end_cyc

  if (Ice%sCS%specified_ice) then ! There is no ice dynamics 	  if (Ice%sCS%specified_ice) then ! There is no ice dynamics 
    call specified_ice_dynamics(sIST, Ice%sCS%OSS, FIA, Ice%s	    call specified_ice_dynamics(sIST, Ice%sCS%OSS, FIA, Ice%s
                                Ice%sCS%specified_ice_CSp, sG	                                Ice%sCS%specified_ice_CSp, sG
  elseif (do_multi_trans) then					  elseif (do_multi_trans) then
    call SIS_multi_dyn_trans(sIST, Ice%sCS%OSS, FIA, Ice%sCS%	    call SIS_multi_dyn_trans(sIST, Ice%sCS%OSS, FIA, Ice%sCS%
                             Ice%icebergs, sG, US, sIG, Ice%s	                             Ice%icebergs, sG, US, sIG, Ice%s
                             Ice%OBC, start_cycle, end_cycle,	                             Ice%OBC, start_cycle, end_cycle,
  elseif (Ice%sCS%slab_ice) then ! Use a very old slab ice mo	  elseif (Ice%sCS%slab_ice) then ! Use a very old slab ice mo
    call slab_ice_dyn_trans(sIST, Ice%sCS%OSS, FIA, Ice%sCS%I	    call slab_ice_dyn_trans(sIST, Ice%sCS%OSS, FIA, Ice%sCS%I
                            sG, US, sIG, Ice%sCS%SIS_tracer_f	                            sG, US, sIG, Ice%sCS%SIS_tracer_f
  else ! This is the typical branch used by SIS2.		  else ! This is the typical branch used by SIS2.
    call SIS_dynamics_trans(sIST, Ice%sCS%OSS, FIA, Ice%sCS%I	    call SIS_dynamics_trans(sIST, Ice%sCS%OSS, FIA, Ice%sCS%I
                            Ice%icebergs, sG, US, sIG, Ice%sC	                            Ice%icebergs, sG, US, sIG, Ice%sC
  endif								  endif

 ! Set up the stresses and surface pressure in the externally	 ! Set up the stresses and surface pressure in the externally
  if (sIST%valid_IST) call ice_mass_from_IST(sIST, Ice%sCS%IO	  if (sIST%valid_IST) call ice_mass_from_IST(sIST, Ice%sCS%IO

  if (Ice%sCS%debug) then					  if (Ice%sCS%debug) then
    call IOF_chksum("Before set_ocean_top_dyn_fluxes", Ice%sC	    call IOF_chksum("Before set_ocean_top_dyn_fluxes", Ice%sC
  endif								  endif
  call set_ocean_top_dyn_fluxes(Ice, Ice%sCS%IOF, FIA, sG, US	  call set_ocean_top_dyn_fluxes(Ice, Ice%sCS%IOF, FIA, sG, US

  if (Ice%sCS%debug) then					  if (Ice%sCS%debug) then
    call Ice_public_type_chksum("End update_ice_dynamics_tran	    call Ice_public_type_chksum("End update_ice_dynamics_tran
  endif								  endif

  !### THIS NO LONGER WORKS ON SLOW ICE PES.			  !### THIS NO LONGER WORKS ON SLOW ICE PES.
!  if (Ice%sCS%bounds_check) then				!  if (Ice%sCS%bounds_check) then
!    call Ice_public_type_bounds_check(Ice, sG, "End update_i	!    call Ice_public_type_bounds_check(Ice, sG, "End update_i
!  endif							!  endif

  call cpu_clock_end(ice_clock_slow) ; call cpu_clock_end(ice	  call cpu_clock_end(ice_clock_slow) ; call cpu_clock_end(ice

end subroutine update_ice_dynamics_trans			end subroutine update_ice_dynamics_trans

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> ice_model_fast_cleanup performs the final steps in the fas	!> ice_model_fast_cleanup performs the final steps in the fas
!! and prepares data to drive the slow ice updates.  This inc	!! and prepares data to drive the slow ice updates.  This inc
!! averaged fluxes and unpacking the land to ice forcing.	!! averaged fluxes and unpacking the land to ice forcing.
subroutine ice_model_fast_cleanup(Ice)				subroutine ice_model_fast_cleanup(Ice)
  type(ice_data_type), intent(inout) :: Ice !< The publicly v	  type(ice_data_type), intent(inout) :: Ice !< The publicly v

  if (.not.associated(Ice%fCS)) call SIS_error(FATAL, &		  if (.not.associated(Ice%fCS)) call SIS_error(FATAL, &
      "The pointer to Ice%fCS must be associated in ice_model	      "The pointer to Ice%fCS must be associated in ice_model

  ! average fluxes from update_ice_model_fast			  ! average fluxes from update_ice_model_fast
  call avg_top_quantities(Ice%fCS%FIA, Ice%fCS%Rad, Ice%fCS%I	  call avg_top_quantities(Ice%fCS%FIA, Ice%fCS%Rad, Ice%fCS%I

  call total_top_quantities(Ice%fCS%FIA, Ice%fCS%TSF, Ice%fCS	  call total_top_quantities(Ice%fCS%FIA, Ice%fCS%TSF, Ice%fCS

  if (allocated(Ice%fCS%IST%t_surf)) &				  if (allocated(Ice%fCS%IST%t_surf)) &
    Ice%fCS%IST%t_surf(:,:,1:) = Ice%fCS%Rad%T_skin(:,:,:) + 	    Ice%fCS%IST%t_surf(:,:,1:) = Ice%fCS%Rad%T_skin(:,:,:) + 
  call infill_array(Ice%fCS%IST, Ice%fCS%sOSS%T_fr_ocn, Ice%f	  call infill_array(Ice%fCS%IST, Ice%fCS%sOSS%T_fr_ocn, Ice%f

end subroutine ice_model_fast_cleanup				end subroutine ice_model_fast_cleanup

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> unpack_land_ice_bdry converts the information in a publicl	!> unpack_land_ice_bdry converts the information in a publicl
!! land_ice_boundary_type into an internally visible fast_ice	!! land_ice_boundary_type into an internally visible fast_ice
subroutine unpack_land_ice_boundary(Ice, LIB)			subroutine unpack_land_ice_boundary(Ice, LIB)
  type(ice_data_type),          intent(inout) :: Ice !< The p	  type(ice_data_type),          intent(inout) :: Ice !< The p
  type(land_ice_boundary_type), intent(in)    :: LIB !< The l	  type(land_ice_boundary_type), intent(in)    :: LIB !< The l

  type(fast_ice_avg_type), pointer :: FIA => NULL()		  type(fast_ice_avg_type), pointer :: FIA => NULL()
  type(SIS_hor_grid_type), pointer :: G => NULL()		  type(SIS_hor_grid_type), pointer :: G => NULL()
  type(unit_scale_type),   pointer :: US => NULL()		  type(unit_scale_type),   pointer :: US => NULL()

  integer :: i, j, k, m, n, i2, j2, k2, isc, iec, jsc, jec, i	  integer :: i, j, k, m, n, i2, j2, k2, isc, iec, jsc, jec, i

  if (.not.associated(Ice%fCS)) call SIS_error(FATAL, &		  if (.not.associated(Ice%fCS)) call SIS_error(FATAL, &
      "The pointer to Ice%fCS must be associated in unpack_la	      "The pointer to Ice%fCS must be associated in unpack_la
  if (.not.associated(Ice%fCS%FIA)) call SIS_error(FATAL, &	  if (.not.associated(Ice%fCS%FIA)) call SIS_error(FATAL, &
      "The pointer to Ice%fCS%FIA must be associated in unpac	      "The pointer to Ice%fCS%FIA must be associated in unpac
  if (.not.associated(Ice%fCS%G)) call SIS_error(FATAL, &	  if (.not.associated(Ice%fCS%G)) call SIS_error(FATAL, &
      "The pointer to Ice%fCS%G must be associated in unpack_	      "The pointer to Ice%fCS%G must be associated in unpack_

  FIA => Ice%fCS%FIA ; G => Ice%fCS%G				  FIA => Ice%fCS%FIA ; G => Ice%fCS%G
  US => Ice%fCS%US						  US => Ice%fCS%US

  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec		  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec

  ! Store liquid runoff and other fluxes from the land to the	  ! Store liquid runoff and other fluxes from the land to the
  i_off = LBOUND(LIB%runoff,1) - G%isc ; j_off = LBOUND(LIB%r	  i_off = LBOUND(LIB%runoff,1) - G%isc ; j_off = LBOUND(LIB%r
  !$OMP parallel do default(none) shared(isc,iec,jsc,jec,FIA,	  !$OMP parallel do default(none) shared(isc,iec,jsc,jec,FIA,
  !$OMP                          private(i2,j2)			  !$OMP                          private(i2,j2)
  do j=jsc,jec ; do i=isc,iec ; if (G%mask2dT(i,j) > 0.0) the	  do j=jsc,jec ; do i=isc,iec ; if (G%mask2dT(i,j) > 0.0) the
    i2 = i+i_off ; j2 = j+j_off					    i2 = i+i_off ; j2 = j+j_off
    FIA%runoff(i,j)  = US%kg_m2s_to_RZ_T*LIB%runoff(i2,j2)	    FIA%runoff(i,j)  = US%kg_m2s_to_RZ_T*LIB%runoff(i2,j2)
    FIA%calving(i,j) = US%kg_m2s_to_RZ_T*LIB%calving(i2,j2)	    FIA%calving(i,j) = US%kg_m2s_to_RZ_T*LIB%calving(i2,j2)
    FIA%runoff_hflx(i,j)  = US%W_m2_to_QRZ_T*LIB%runoff_hflx(	    FIA%runoff_hflx(i,j)  = US%W_m2_to_QRZ_T*LIB%runoff_hflx(
    FIA%calving_hflx(i,j) = US%W_m2_to_QRZ_T*LIB%calving_hflx	    FIA%calving_hflx(i,j) = US%W_m2_to_QRZ_T*LIB%calving_hflx
  else								  else
    ! This is a land point from the perspective of the sea-ic	    ! This is a land point from the perspective of the sea-ic
    ! At some point it might make sense to check for non-zero	    ! At some point it might make sense to check for non-zero
    ! might indicate regridding errors.  However, bad-data va	    ! might indicate regridding errors.  However, bad-data va
    ! non-zero and should not be flagged.			    ! non-zero and should not be flagged.
    FIA%runoff(i,j)  = 0.0 ; FIA%calving(i,j) = 0.0		    FIA%runoff(i,j)  = 0.0 ; FIA%calving(i,j) = 0.0
    FIA%runoff_hflx(i,j)  = 0.0 ; FIA%calving_hflx(i,j) = 0.0	    FIA%runoff_hflx(i,j)  = 0.0 ; FIA%calving_hflx(i,j) = 0.0
  endif ; enddo ; enddo						  endif ; enddo ; enddo

  if (Ice%fCS%debug) then					  if (Ice%fCS%debug) then
    call FIA_chksum("End of unpack_land_ice_boundary", FIA, G	    call FIA_chksum("End of unpack_land_ice_boundary", FIA, G
  endif								  endif

end subroutine unpack_land_ice_boundary				end subroutine unpack_land_ice_boundary

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> This subroutine copies information (mostly fluxes and the 	!> This subroutine copies information (mostly fluxes and the 
!! from the fast part of the sea-ice to the  slow part of the	!! from the fast part of the sea-ice to the  slow part of the
subroutine exchange_fast_to_slow_ice(Ice)			subroutine exchange_fast_to_slow_ice(Ice)
  type(ice_data_type), &					  type(ice_data_type), &
    intent(inout) :: Ice            !< The publicly visible i	    intent(inout) :: Ice            !< The publicly visible i
                                    !! part is to be exchange	                                    !! part is to be exchange
  type(fast_ice_avg_type),   pointer :: FIA_null => NULL()	  type(fast_ice_avg_type),   pointer :: FIA_null => NULL()
  type(ice_state_type),      pointer :: IST_null => NULL()	  type(ice_state_type),      pointer :: IST_null => NULL()
  type(ice_rad_type),        pointer :: Rad_null => NULL()	  type(ice_rad_type),        pointer :: Rad_null => NULL()
  type(total_sfc_flux_type), pointer :: TSF_null => NULL()	  type(total_sfc_flux_type), pointer :: TSF_null => NULL()

  integer :: isc, iec, jsc, jec, isd, ied, jsd, jed		  integer :: isc, iec, jsc, jec, isd, ied, jsd, jed
  logical :: redo_fast_update					  logical :: redo_fast_update

  redo_fast_update = .false.					  redo_fast_update = .false.
  if (associated(Ice%fCS)) redo_fast_update = Ice%fCS%redo_fa	  if (associated(Ice%fCS)) redo_fast_update = Ice%fCS%redo_fa
  if (associated(Ice%sCS)) redo_fast_update = Ice%sCS%redo_fa	  if (associated(Ice%sCS)) redo_fast_update = Ice%sCS%redo_fa

  if (associated(Ice%fCS)) then					  if (associated(Ice%fCS)) then
    isc = Ice%fCS%G%isc ; iec = Ice%fCS%G%iec ; jsc = Ice%fCS	    isc = Ice%fCS%G%isc ; iec = Ice%fCS%G%iec ; jsc = Ice%fCS
    isd = Ice%fCS%G%isd ; ied = Ice%fCS%G%ied ; jsd = Ice%fCS	    isd = Ice%fCS%G%isd ; ied = Ice%fCS%G%ied ; jsd = Ice%fCS

    ! Propagate the coupler_type info to Ice%fCS%FIA%tr_flux 	    ! Propagate the coupler_type info to Ice%fCS%FIA%tr_flux 
    call coupler_type_spawn(Ice%ocean_fluxes, Ice%fCS%FIA%tr_	    call coupler_type_spawn(Ice%ocean_fluxes, Ice%fCS%FIA%tr_
                            (/isd, isc, iec, ied/),  (/jsd, j	                            (/isd, isc, iec, ied/),  (/jsd, j
                            (/0, Ice%fCS%IG%CatIce/), as_need	                            (/0, Ice%fCS%IG%CatIce/), as_need

    if (redo_fast_update) &					    if (redo_fast_update) &
      ! Propagate the coupler_type info to Ice%fCS%TSF%tr_flu	      ! Propagate the coupler_type info to Ice%fCS%TSF%tr_flu
      call coupler_type_spawn(Ice%ocean_fluxes, Ice%fCS%TSF%t	      call coupler_type_spawn(Ice%ocean_fluxes, Ice%fCS%TSF%t
                              (/isd, isc, iec, ied/),  (/jsd,	                              (/isd, isc, iec, ied/),  (/jsd,
  endif								  endif

  if (associated(Ice%sCS)) then					  if (associated(Ice%sCS)) then
    isc = Ice%sCS%G%isc ; iec = Ice%sCS%G%iec ; jsc = Ice%sCS	    isc = Ice%sCS%G%isc ; iec = Ice%sCS%G%iec ; jsc = Ice%sCS
    isd = Ice%sCS%G%isd ; ied = Ice%sCS%G%ied ; jsd = Ice%sCS	    isd = Ice%sCS%G%isd ; ied = Ice%sCS%G%ied ; jsd = Ice%sCS

    ! Propagate the coupler_type info to Ice%sCS%FIA%tr_flux 	    ! Propagate the coupler_type info to Ice%sCS%FIA%tr_flux 
    call coupler_type_spawn(Ice%ocean_fluxes, Ice%sCS%FIA%tr_	    call coupler_type_spawn(Ice%ocean_fluxes, Ice%sCS%FIA%tr_
                            (/isd, isc, iec, ied/),  (/jsd, j	                            (/isd, isc, iec, ied/),  (/jsd, j
                            (/0, Ice%sCS%IG%CatIce/), as_need	                            (/0, Ice%sCS%IG%CatIce/), as_need

    if (redo_fast_update) &					    if (redo_fast_update) &
      ! Propagate the coupler_type info to Ice%sCS%TSF%tr_flu	      ! Propagate the coupler_type info to Ice%sCS%TSF%tr_flu
      call coupler_type_spawn(Ice%ocean_fluxes, Ice%sCS%TSF%t	      call coupler_type_spawn(Ice%ocean_fluxes, Ice%sCS%TSF%t
                              (/isd, isc, iec, ied/),  (/jsd,	                              (/isd, isc, iec, ied/),  (/jsd,
  endif								  endif

  if (Ice%xtype == DIRECT) then					  if (Ice%xtype == DIRECT) then
    if (.not.associated(Ice%fCS) .or. .not.associated(Ice%sCS	    if (.not.associated(Ice%fCS) .or. .not.associated(Ice%sCS
      "With xtype=DIRECT, both the pointer to Ice%sCS and the	      "With xtype=DIRECT, both the pointer to Ice%sCS and the
      "associated (although perhaps not with each other) in e	      "associated (although perhaps not with each other) in e

    if (.not.associated(Ice%fCS%FIA, Ice%sCS%FIA)) then		    if (.not.associated(Ice%fCS%FIA, Ice%sCS%FIA)) then
      call copy_FIA_to_FIA(Ice%fCS%FIA, Ice%sCS%FIA, Ice%fCS%	      call copy_FIA_to_FIA(Ice%fCS%FIA, Ice%sCS%FIA, Ice%fCS%
    endif							    endif

    if (redo_fast_update) then					    if (redo_fast_update) then
      if (.not.associated(Ice%fCS%TSF, Ice%sCS%TSF)) &		      if (.not.associated(Ice%fCS%TSF, Ice%sCS%TSF)) &
        call copy_TSF_to_TSF(Ice%fCS%TSF, Ice%sCS%TSF, Ice%fC	        call copy_TSF_to_TSF(Ice%fCS%TSF, Ice%sCS%TSF, Ice%fC
      if (.not.associated(Ice%fCS%Rad, Ice%sCS%Rad)) &		      if (.not.associated(Ice%fCS%Rad, Ice%sCS%Rad)) &
        call copy_Rad_to_Rad(Ice%fCS%Rad, Ice%sCS%Rad, Ice%fC	        call copy_Rad_to_Rad(Ice%fCS%Rad, Ice%sCS%Rad, Ice%fC
    else							    else
      if (.not.associated(Ice%fCS%IST, Ice%sCS%IST)) &		      if (.not.associated(Ice%fCS%IST, Ice%sCS%IST)) &
        call copy_IST_to_IST(Ice%fCS%IST, Ice%sCS%IST, Ice%fC	        call copy_IST_to_IST(Ice%fCS%IST, Ice%sCS%IST, Ice%fC
    endif							    endif
  elseif (Ice%xtype == REDIST) then				  elseif (Ice%xtype == REDIST) then
    if (.not.associated(Ice%fCS) .and. .not.associated(Ice%sC	    if (.not.associated(Ice%fCS) .and. .not.associated(Ice%sC
      "Either the pointer to Ice%sCS or the pointer to Ice%fC	      "Either the pointer to Ice%sCS or the pointer to Ice%fC
      "associated in exchange_fast_to_slow_ice.")		      "associated in exchange_fast_to_slow_ice.")

    if (associated(Ice%fCS) .and. associated(Ice%sCS)) then	    if (associated(Ice%fCS) .and. associated(Ice%sCS)) then
      if (.not.associated(Ice%fCS%FIA, Ice%sCS%FIA)) &		      if (.not.associated(Ice%fCS%FIA, Ice%sCS%FIA)) &
        call redistribute_FIA_to_FIA(Ice%fCS%FIA, Ice%sCS%FIA	        call redistribute_FIA_to_FIA(Ice%fCS%FIA, Ice%sCS%FIA
                                     Ice%slow_domain, Ice%sCS	                                     Ice%slow_domain, Ice%sCS

      if (redo_fast_update) then				      if (redo_fast_update) then
        call redistribute_TSF_to_TSF(Ice%fCS%TSF, Ice%sCS%TSF	        call redistribute_TSF_to_TSF(Ice%fCS%TSF, Ice%sCS%TSF
                                     Ice%slow_domain, Ice%sCS	                                     Ice%slow_domain, Ice%sCS
        call redistribute_Rad_to_Rad(Ice%fCS%Rad, Ice%sCS%Rad	        call redistribute_Rad_to_Rad(Ice%fCS%Rad, Ice%sCS%Rad
      else							      else
        if (.not.associated(Ice%fCS%IST, Ice%sCS%IST)) &	        if (.not.associated(Ice%fCS%IST, Ice%sCS%IST)) &
          call redistribute_IST_to_IST(Ice%fCS%IST, Ice%sCS%I	          call redistribute_IST_to_IST(Ice%fCS%IST, Ice%sCS%I
      endif							      endif
    elseif (associated(Ice%fCS)) then				    elseif (associated(Ice%fCS)) then
      call redistribute_FIA_to_FIA(Ice%fCS%FIA, FIA_null, Ice	      call redistribute_FIA_to_FIA(Ice%fCS%FIA, FIA_null, Ice
      if (redo_fast_update) then				      if (redo_fast_update) then
        call redistribute_TSF_to_TSF(Ice%fCS%TSF, TSF_null, I	        call redistribute_TSF_to_TSF(Ice%fCS%TSF, TSF_null, I
        call redistribute_Rad_to_Rad(Ice%fCS%Rad, Rad_null, I	        call redistribute_Rad_to_Rad(Ice%fCS%Rad, Rad_null, I
      else							      else
        call redistribute_IST_to_IST(Ice%fCS%IST, IST_null, I	        call redistribute_IST_to_IST(Ice%fCS%IST, IST_null, I
      endif							      endif
    elseif (associated(Ice%sCS)) then				    elseif (associated(Ice%sCS)) then
      call redistribute_FIA_to_FIA(FIA_null, Ice%sCS%FIA, Ice	      call redistribute_FIA_to_FIA(FIA_null, Ice%sCS%FIA, Ice
                                   Ice%slow_domain, Ice%sCS%G	                                   Ice%slow_domain, Ice%sCS%G
      if (redo_fast_update) then				      if (redo_fast_update) then
        call redistribute_TSF_to_TSF(TSF_null, Ice%sCS%TSF, I	        call redistribute_TSF_to_TSF(TSF_null, Ice%sCS%TSF, I
                                     Ice%slow_domain, Ice%sCS	                                     Ice%slow_domain, Ice%sCS
        call redistribute_Rad_to_Rad(Rad_null, Ice%sCS%Rad, I	        call redistribute_Rad_to_Rad(Rad_null, Ice%sCS%Rad, I
      else							      else
        call redistribute_IST_to_IST(IST_null, Ice%sCS%IST, I	        call redistribute_IST_to_IST(IST_null, Ice%sCS%IST, I
      endif							      endif
    else							    else
      call SIS_error(FATAL, "Either the pointer to Ice%sCS or	      call SIS_error(FATAL, "Either the pointer to Ice%sCS or
                     "Ice%fCS must be associated in exchange_	                     "Ice%fCS must be associated in exchange_
    endif							    endif
  else								  else
    call SIS_error(FATAL, "exchange_fast_to_slow_ice called w	    call SIS_error(FATAL, "exchange_fast_to_slow_ice called w
  endif								  endif

end subroutine exchange_fast_to_slow_ice			end subroutine exchange_fast_to_slow_ice


!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> set_ocean_top_fluxes translates ice-bottom fluxes of heat,	!> set_ocean_top_fluxes translates ice-bottom fluxes of heat,
!!  tracers from the ice model's internal state to the public	!!  tracers from the ice model's internal state to the public
!!  for use by the ocean model.					!!  for use by the ocean model.
subroutine set_ocean_top_fluxes(Ice, IST, IOF, FIA, OSS, G, U	subroutine set_ocean_top_fluxes(Ice, IST, IOF, FIA, OSS, G, U
  type(ice_data_type),        intent(inout) :: Ice !< The pub	  type(ice_data_type),        intent(inout) :: Ice !< The pub
  type(ice_state_type),       intent(inout) :: IST !< A type 	  type(ice_state_type),       intent(inout) :: IST !< A type 
  type(ice_ocean_flux_type),  intent(in)    :: IOF !< A struc	  type(ice_ocean_flux_type),  intent(in)    :: IOF !< A struc
                                                   !! the oce	                                                   !! the oce
  type(fast_ice_avg_type),    intent(in)    :: FIA !< A type 	  type(fast_ice_avg_type),    intent(in)    :: FIA !< A type 
                                                   !! (mostly	                                                   !! (mostly
  type(ocean_sfc_state_type), intent(in)    :: OSS !< A struc	  type(ocean_sfc_state_type), intent(in)    :: OSS !< A struc
                                                   !! the oce	                                                   !! the oce
  type(SIS_hor_grid_type),    intent(inout) :: G   !< The hor	  type(SIS_hor_grid_type),    intent(inout) :: G   !< The hor
  type(unit_scale_type),      intent(in)    :: US  !< A struc	  type(unit_scale_type),      intent(in)    :: US  !< A struc
  type(ice_grid_type),        intent(in)    :: IG  !< The sea	  type(ice_grid_type),        intent(in)    :: IG  !< The sea
  type(SIS_slow_CS),          intent(in)    :: sCS !< The slo	  type(SIS_slow_CS),          intent(in)    :: sCS !< The slo

  real :: I_count						  real :: I_count
  integer :: i, j, k, isc, iec, jsc, jec, m, n			  integer :: i, j, k, isc, iec, jsc, jec, m, n
  integer :: i2, j2, i_off, j_off, ncat, NkIce			  integer :: i2, j2, i_off, j_off, ncat, NkIce
  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec		  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec
  ncat = IG%CatIce ; NkIce = IG%NkIce				  ncat = IG%CatIce ; NkIce = IG%NkIce

  if (sCS%debug) then						  if (sCS%debug) then
    call Ice_public_type_chksum("Start set_ocean_top_fluxes",	    call Ice_public_type_chksum("Start set_ocean_top_fluxes",
    call IOF_chksum("Start set_ocean_top_fluxes", IOF, G, sCS	    call IOF_chksum("Start set_ocean_top_fluxes", IOF, G, sCS
    call FIA_chksum("Start set_ocean_top_fluxes", FIA, G, US)	    call FIA_chksum("Start set_ocean_top_fluxes", FIA, G, US)
  endif								  endif

!   It is possible that the ice mass and surface pressure wil	!   It is possible that the ice mass and surface pressure wil
! the thermodynamic step, in which case this should be uncomm	! the thermodynamic step, in which case this should be uncomm
!  ! Sum the concentration weighted mass.			!  ! Sum the concentration weighted mass.
!  Ice%mi(:,:) = 0.0						!  Ice%mi(:,:) = 0.0
!  i_off = LBOUND(Ice%mi,1) - G%isc ; j_off = LBOUND(Ice%mi,2	!  i_off = LBOUND(Ice%mi,1) - G%isc ; j_off = LBOUND(Ice%mi,2
!  !$OMP parallel do default(shared) private(i2,j2)		!  !$OMP parallel do default(shared) private(i2,j2)
!  do j=jsc,jec ; do k=1,ncat ; do i=isc,iec			!  do j=jsc,jec ; do k=1,ncat ; do i=isc,iec
!    i2 = i+i_off ; j2 = j+j_off! Use these to correct for in	!    i2 = i+i_off ; j2 = j+j_off! Use these to correct for in
!    Ice%mi(i2,j2) = Ice%mi(i2,j2) + IST%part_size(i,j,k) * &	!    Ice%mi(i2,j2) = Ice%mi(i2,j2) + IST%part_size(i,j,k) * &
!        (G%US%RZ_to_kg_m2 * ((IST%mH_snow(i,j,k) + IST%mH_po	!        (G%US%RZ_to_kg_m2 * ((IST%mH_snow(i,j,k) + IST%mH_po
!  enddo ; enddo ; enddo					!  enddo ; enddo ; enddo

  ! This block of code is probably unnecessary.			  ! This block of code is probably unnecessary.
  Ice%flux_t(:,:) = 0.0 ; Ice%flux_q(:,:) = 0.0			  Ice%flux_t(:,:) = 0.0 ; Ice%flux_q(:,:) = 0.0
  Ice%flux_sw_nir_dir(:,:) = 0.0 ; Ice%flux_sw_nir_dif(:,:) =	  Ice%flux_sw_nir_dir(:,:) = 0.0 ; Ice%flux_sw_nir_dif(:,:) =
  Ice%flux_sw_vis_dir(:,:) = 0.0 ; Ice%flux_sw_vis_dif(:,:) =	  Ice%flux_sw_vis_dir(:,:) = 0.0 ; Ice%flux_sw_vis_dif(:,:) =
  Ice%flux_lw(:,:) = 0.0 ; Ice%flux_lh(:,:) = 0.0		  Ice%flux_lw(:,:) = 0.0 ; Ice%flux_lh(:,:) = 0.0
  Ice%fprec(:,:) = 0.0 ; Ice%lprec(:,:) = 0.0			  Ice%fprec(:,:) = 0.0 ; Ice%lprec(:,:) = 0.0
  call coupler_type_rescale_data(Ice%ocean_fluxes, 0.0)		  call coupler_type_rescale_data(Ice%ocean_fluxes, 0.0)

  i_off = LBOUND(Ice%flux_t,1) - G%isc ; j_off = LBOUND(Ice%f	  i_off = LBOUND(Ice%flux_t,1) - G%isc ; j_off = LBOUND(Ice%f
  !$OMP parallel do default(none) shared(isc,iec,jsc,jec,Ice,	  !$OMP parallel do default(none) shared(isc,iec,jsc,jec,Ice,
  !$OMP                           private(i2,j2)		  !$OMP                           private(i2,j2)
  do j=jsc,jec ; do i=isc,iec					  do j=jsc,jec ; do i=isc,iec
    i2 = i+i_off ; j2 = j+j_off! Use these to correct for ind	    i2 = i+i_off ; j2 = j+j_off! Use these to correct for ind
    Ice%flux_t(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_sh_ocn_top(	    Ice%flux_t(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_sh_ocn_top(
    Ice%flux_q(i2,j2) = US%RZ_T_to_kg_m2s*IOF%evap_ocn_top(i,	    Ice%flux_q(i2,j2) = US%RZ_T_to_kg_m2s*IOF%evap_ocn_top(i,
    Ice%flux_sw_vis_dir(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_sw	    Ice%flux_sw_vis_dir(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_sw
    Ice%flux_sw_vis_dif(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_sw	    Ice%flux_sw_vis_dif(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_sw
    Ice%flux_sw_nir_dir(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_sw	    Ice%flux_sw_nir_dir(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_sw
    Ice%flux_sw_nir_dif(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_sw	    Ice%flux_sw_nir_dif(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_sw
    Ice%flux_lw(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_lw_ocn_top	    Ice%flux_lw(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_lw_ocn_top
    Ice%flux_lh(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_lh_ocn_top	    Ice%flux_lh(i2,j2) = US%QRZ_T_to_W_m2*IOF%flux_lh_ocn_top
    Ice%fprec(i2,j2) = US%RZ_T_to_kg_m2s*IOF%fprec_ocn_top(i,	    Ice%fprec(i2,j2) = US%RZ_T_to_kg_m2s*IOF%fprec_ocn_top(i,
    Ice%lprec(i2,j2) = US%RZ_T_to_kg_m2s*IOF%lprec_ocn_top(i,	    Ice%lprec(i2,j2) = US%RZ_T_to_kg_m2s*IOF%lprec_ocn_top(i,
    Ice%runoff(i2,j2)  = US%RZ_T_to_kg_m2s*FIA%runoff(i,j)	    Ice%runoff(i2,j2)  = US%RZ_T_to_kg_m2s*FIA%runoff(i,j)
    Ice%calving(i2,j2) = US%RZ_T_to_kg_m2s*FIA%calving(i,j)	    Ice%calving(i2,j2) = US%RZ_T_to_kg_m2s*FIA%calving(i,j)
    Ice%runoff_hflx(i2,j2)  = US%QRZ_T_to_W_m2*FIA%runoff_hfl	    Ice%runoff_hflx(i2,j2)  = US%QRZ_T_to_W_m2*FIA%runoff_hfl
    Ice%calving_hflx(i2,j2) = US%QRZ_T_to_W_m2*FIA%calving_hf	    Ice%calving_hflx(i2,j2) = US%QRZ_T_to_W_m2*FIA%calving_hf
    Ice%flux_salt(i2,j2) = US%S_to_ppt*US%RZ_T_to_kg_m2s*IOF%	    Ice%flux_salt(i2,j2) = US%S_to_ppt*US%RZ_T_to_kg_m2s*IOF%
    Ice%SST_C(i2,j2) = US%C_to_degC*OSS%SST_C(i,j)		    Ice%SST_C(i2,j2) = US%C_to_degC*OSS%SST_C(i,j)

!   It is possible that the ice mass and surface pressure wil	!   It is possible that the ice mass and surface pressure wil
! the thermodynamic step, in which case this should be uncomm	! the thermodynamic step, in which case this should be uncomm
!  if (IOF%slp2ocean) then					!  if (IOF%slp2ocean) then
!     Ice%p_surf(i2,j2) = US%RZ_T_to_kg_m2s*US%L_T_to_m_s*FIA	!     Ice%p_surf(i2,j2) = US%RZ_T_to_kg_m2s*US%L_T_to_m_s*FIA
!   else							!   else
!     Ice%p_surf(i2,j2) = 0.0					!     Ice%p_surf(i2,j2) = 0.0
!   endif							!   endif
!   Ice%p_surf(i2,j2) = Ice%p_surf(i2,j2) + US%L_T_to_m_s**2*	!   Ice%p_surf(i2,j2) = Ice%p_surf(i2,j2) + US%L_T_to_m_s**2*
  enddo ; enddo							  enddo ; enddo
  if (allocated(IOF%melt_nudge)) then				  if (allocated(IOF%melt_nudge)) then
    do j=jsc,jec ; do i=isc,iec					    do j=jsc,jec ; do i=isc,iec
      i2 = i+i_off ; j2 = j+j_off! Use these to correct for i	      i2 = i+i_off ; j2 = j+j_off! Use these to correct for i
      Ice%lprec(i2,j2) = Ice%lprec(i2,j2) + US%RZ_T_to_kg_m2s	      Ice%lprec(i2,j2) = Ice%lprec(i2,j2) + US%RZ_T_to_kg_m2s
    enddo ; enddo						    enddo ; enddo
  endif								  endif

  ! This copy may need to be skipped in the first step of a c	  ! This copy may need to be skipped in the first step of a c
  ! coupling, but otherwise if it is skipped may indicate a p	  ! coupling, but otherwise if it is skipped may indicate a p
  if (coupler_type_initialized(IOF%tr_flux_ocn_top)) &		  if (coupler_type_initialized(IOF%tr_flux_ocn_top)) &
    call coupler_type_copy_data(IOF%tr_flux_ocn_top, Ice%ocea	    call coupler_type_copy_data(IOF%tr_flux_ocn_top, Ice%ocea

  if (sCS%debug) then						  if (sCS%debug) then
    call Ice_public_type_chksum("End set_ocean_top_fluxes", I	    call Ice_public_type_chksum("End set_ocean_top_fluxes", I
  endif								  endif

end subroutine set_ocean_top_fluxes				end subroutine set_ocean_top_fluxes

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> ice_mass_from_IST stores the total ice mass determined fro	!> ice_mass_from_IST stores the total ice mass determined fro
subroutine ice_mass_from_IST(IST, IOF, G, IG)			subroutine ice_mass_from_IST(IST, IOF, G, IG)
  type(ice_state_type),       intent(inout) :: IST !< A type 	  type(ice_state_type),       intent(inout) :: IST !< A type 
  type(ice_ocean_flux_type),  intent(inout) :: IOF !< A struc	  type(ice_ocean_flux_type),  intent(inout) :: IOF !< A struc
                                                   !! the oce	                                                   !! the oce
  type(SIS_hor_grid_type),    intent(inout) :: G   !< The hor	  type(SIS_hor_grid_type),    intent(inout) :: G   !< The hor
  type(ice_grid_type),        intent(in)    :: IG  !< The sea	  type(ice_grid_type),        intent(in)    :: IG  !< The sea

  integer :: i, j, k, isc, iec, jsc, jec, ncat			  integer :: i, j, k, isc, iec, jsc, jec, ncat
  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec ; nca	  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec ; nca

  ! Sum the concentration weighted mass.			  ! Sum the concentration weighted mass.
  IOF%mass_ice_sn_p(:,:) = 0.0					  IOF%mass_ice_sn_p(:,:) = 0.0
  !$OMP parallel do default(shared)				  !$OMP parallel do default(shared)
  do j=jsc,jec ; do k=1,ncat ; do i=isc,iec			  do j=jsc,jec ; do k=1,ncat ; do i=isc,iec
    IOF%mass_ice_sn_p(i,j) = IOF%mass_ice_sn_p(i,j) + IST%par	    IOF%mass_ice_sn_p(i,j) = IOF%mass_ice_sn_p(i,j) + IST%par
          ((IST%mH_snow(i,j,k) + IST%mH_pond(i,j,k)) + IST%mH	          ((IST%mH_snow(i,j,k) + IST%mH_pond(i,j,k)) + IST%mH
  enddo ; enddo ; enddo						  enddo ; enddo ; enddo

end subroutine ice_mass_from_IST				end subroutine ice_mass_from_IST


!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> set_ocean_top_dyn_fluxes translates ice-bottom stresses an	!> set_ocean_top_dyn_fluxes translates ice-bottom stresses an
!!  model's ice-ocean flux type and the fast-ice average type	!!  model's ice-ocean flux type and the fast-ice average type
!!  ice data type for use by the ocean model.			!!  ice data type for use by the ocean model.
subroutine set_ocean_top_dyn_fluxes(Ice, IOF, FIA, G, US, sCS	subroutine set_ocean_top_dyn_fluxes(Ice, IOF, FIA, G, US, sCS
  type(ice_data_type),        intent(inout) :: Ice !< The pub	  type(ice_data_type),        intent(inout) :: Ice !< The pub
  type(ice_ocean_flux_type),  intent(in)    :: IOF !< A struc	  type(ice_ocean_flux_type),  intent(in)    :: IOF !< A struc
                                                   !! the oce	                                                   !! the oce
  type(fast_ice_avg_type),    intent(in)    :: FIA !< A type 	  type(fast_ice_avg_type),    intent(in)    :: FIA !< A type 
                                                   !! (mostly	                                                   !! (mostly
  type(SIS_hor_grid_type),    intent(inout) :: G   !< The hor	  type(SIS_hor_grid_type),    intent(inout) :: G   !< The hor
  type(unit_scale_type),      intent(in)    :: US  !< A struc	  type(unit_scale_type),      intent(in)    :: US  !< A struc
  type(SIS_slow_CS),          intent(in)    :: sCS !< The slo	  type(SIS_slow_CS),          intent(in)    :: sCS !< The slo

  real :: I_count						  real :: I_count
  integer :: i, j, k, isc, iec, jsc, jec			  integer :: i, j, k, isc, iec, jsc, jec
  integer :: i2, j2, i_off, j_off, ind				  integer :: i2, j2, i_off, j_off, ind
  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec		  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec

  if (sCS%debug) then						  if (sCS%debug) then
    call Ice_public_type_chksum("Start set_ocean_top_dyn_flux	    call Ice_public_type_chksum("Start set_ocean_top_dyn_flux
    call IOF_chksum("Start set_ocean_top_dyn_fluxes", IOF, G,	    call IOF_chksum("Start set_ocean_top_dyn_fluxes", IOF, G,
  endif								  endif

  ! Sum the concentration weighted mass.			  ! Sum the concentration weighted mass.
  Ice%mi(:,:) = 0.0						  Ice%mi(:,:) = 0.0
  i_off = LBOUND(Ice%mi,1) - G%isc ; j_off = LBOUND(Ice%mi,2)	  i_off = LBOUND(Ice%mi,1) - G%isc ; j_off = LBOUND(Ice%mi,2)
  !$OMP parallel do default(shared) private(i2,j2)		  !$OMP parallel do default(shared) private(i2,j2)
  do j=jsc,jec ; do i=isc,iec					  do j=jsc,jec ; do i=isc,iec
    i2 = i+i_off ; j2 = j+j_off! Use these to correct for ind	    i2 = i+i_off ; j2 = j+j_off! Use these to correct for ind
    Ice%mi(i2,j2) = Ice%mi(i2,j2) + US%RZ_to_kg_m2*IOF%mass_i	    Ice%mi(i2,j2) = Ice%mi(i2,j2) + US%RZ_to_kg_m2*IOF%mass_i
  enddo ; enddo							  enddo ; enddo

  if (sCS%do_icebergs .and. associated(IOF%mass_berg)) then	  if (sCS%do_icebergs .and. associated(IOF%mass_berg)) then
    ! Note that the IOF berg fields and Ice fields are only a	    ! Note that the IOF berg fields and Ice fields are only a
    ! computational domains, although they may use different 	    ! computational domains, although they may use different 
    Ice%mi(:,:) = Ice%mi(:,:) + IOF%mass_berg(:,:)		    Ice%mi(:,:) = Ice%mi(:,:) + IOF%mass_berg(:,:)
    if (sCS%pass_iceberg_area_to_ocean) then			    if (sCS%pass_iceberg_area_to_ocean) then
      Ice%mass_berg(:,:) = IOF%mass_berg(:,:)			      Ice%mass_berg(:,:) = IOF%mass_berg(:,:)
      if (associated(IOF%ustar_berg)) Ice%ustar_berg(:,:) = I	      if (associated(IOF%ustar_berg)) Ice%ustar_berg(:,:) = I
      if (associated(IOF%area_berg))  Ice%area_berg(:,:) = IO	      if (associated(IOF%area_berg))  Ice%area_berg(:,:) = IO
    endif							    endif
  endif								  endif

  i_off = LBOUND(Ice%flux_t,1) - G%isc ; j_off = LBOUND(Ice%f	  i_off = LBOUND(Ice%flux_t,1) - G%isc ; j_off = LBOUND(Ice%f
  !$OMP parallel do default(shared) private(i2,j2)		  !$OMP parallel do default(shared) private(i2,j2)
  do j=jsc,jec ; do i=isc,iec					  do j=jsc,jec ; do i=isc,iec
    i2 = i+i_off ; j2 = j+j_off! Use these to correct for ind	    i2 = i+i_off ; j2 = j+j_off! Use these to correct for ind
    Ice%flux_u(i2,j2) = US%RZ_T_to_kg_m2s*US%L_T_to_m_s*IOF%f	    Ice%flux_u(i2,j2) = US%RZ_T_to_kg_m2s*US%L_T_to_m_s*IOF%f
    Ice%flux_v(i2,j2) = US%RZ_T_to_kg_m2s*US%L_T_to_m_s*IOF%f	    Ice%flux_v(i2,j2) = US%RZ_T_to_kg_m2s*US%L_T_to_m_s*IOF%f

    if (IOF%slp2ocean) then					    if (IOF%slp2ocean) then
      Ice%p_surf(i2,j2) = US%RZ_T_to_kg_m2s*US%L_T_to_m_s*FIA	      Ice%p_surf(i2,j2) = US%RZ_T_to_kg_m2s*US%L_T_to_m_s*FIA
    else							    else
      Ice%p_surf(i2,j2) = 0.0					      Ice%p_surf(i2,j2) = 0.0
    endif							    endif
    Ice%p_surf(i2,j2) = Ice%p_surf(i2,j2) + US%L_T_to_m_s**2*	    Ice%p_surf(i2,j2) = Ice%p_surf(i2,j2) + US%L_T_to_m_s**2*
  enddo ; enddo							  enddo ; enddo
  if (associated(Ice%stress_mag) .and. allocated(IOF%stress_m	  if (associated(Ice%stress_mag) .and. allocated(IOF%stress_m
    i_off = LBOUND(Ice%stress_mag,1) - G%isc ; j_off = LBOUND	    i_off = LBOUND(Ice%stress_mag,1) - G%isc ; j_off = LBOUND
    !$OMP parallel do default(shared) private(i2,j2)		    !$OMP parallel do default(shared) private(i2,j2)
    do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off	    do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off
      Ice%stress_mag(i2,j2) = US%RZ_T_to_kg_m2s*US%L_T_to_m_s	      Ice%stress_mag(i2,j2) = US%RZ_T_to_kg_m2s*US%L_T_to_m_s
    enddo ; enddo						    enddo ; enddo
  endif								  endif

  if (sCS%debug) then						  if (sCS%debug) then
    call Ice_public_type_chksum("End set_ocean_top_dyn_fluxes	    call Ice_public_type_chksum("End set_ocean_top_dyn_fluxes
  endif								  endif

end subroutine set_ocean_top_dyn_fluxes				end subroutine set_ocean_top_dyn_fluxes


!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> This subroutine copies information from the slow part of t	!> This subroutine copies information from the slow part of t
!! fast part of the sea ice.					!! fast part of the sea ice.
subroutine exchange_slow_to_fast_ice(Ice)			subroutine exchange_slow_to_fast_ice(Ice)
  type(ice_data_type), &					  type(ice_data_type), &
    intent(inout) :: Ice            !< The publicly visible i	    intent(inout) :: Ice            !< The publicly visible i
                                    !! part is to be exchange	                                    !! part is to be exchange
  type(simple_OSS_type), pointer :: sOSS_null => NULL()		  type(simple_OSS_type), pointer :: sOSS_null => NULL()
  type(ice_state_type),  pointer :: IST_null => NULL()		  type(ice_state_type),  pointer :: IST_null => NULL()

  integer :: isc, iec, jsc, jec, isd, ied, jsd, jed		  integer :: isc, iec, jsc, jec, isd, ied, jsd, jed

  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c	  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c

  if (associated(Ice%fCS)) then					  if (associated(Ice%fCS)) then
    isc = Ice%fCS%G%isc ; iec = Ice%fCS%G%iec ; jsc = Ice%fCS	    isc = Ice%fCS%G%isc ; iec = Ice%fCS%G%iec ; jsc = Ice%fCS
    isd = Ice%fCS%G%isd ; ied = Ice%fCS%G%ied ; jsd = Ice%fCS	    isd = Ice%fCS%G%isd ; ied = Ice%fCS%G%ied ; jsd = Ice%fCS

    ! Propagate the coupler_type info to Ice%fCS%sOSS%tr_fiel	    ! Propagate the coupler_type info to Ice%fCS%sOSS%tr_fiel
    call coupler_type_spawn(Ice%ocean_fields, Ice%fCS%sOSS%tr	    call coupler_type_spawn(Ice%ocean_fields, Ice%fCS%sOSS%tr
                            (/isd, isc, iec, ied/),  (/jsd, j	                            (/isd, isc, iec, ied/),  (/jsd, j
  endif								  endif

  if (Ice%xtype == DIRECT) then					  if (Ice%xtype == DIRECT) then
    if (.not.associated(Ice%fCS) .or. .not.associated(Ice%sCS	    if (.not.associated(Ice%fCS) .or. .not.associated(Ice%sCS
      "With xtype=DIRECT, both the pointer to Ice%sCS and the	      "With xtype=DIRECT, both the pointer to Ice%sCS and the
      "associated (although perhaps not with each other) in e	      "associated (although perhaps not with each other) in e

    if (.not.associated(Ice%fCS%sOSS, Ice%sCS%sOSS)) then	    if (.not.associated(Ice%fCS%sOSS, Ice%sCS%sOSS)) then
      call copy_sOSS_to_sOSS(Ice%sCS%sOSS, Ice%fCS%sOSS, Ice%	      call copy_sOSS_to_sOSS(Ice%sCS%sOSS, Ice%fCS%sOSS, Ice%
    endif							    endif

    if (.not.associated(Ice%fCS%IST, Ice%sCS%IST)) then		    if (.not.associated(Ice%fCS%IST, Ice%sCS%IST)) then
      call copy_IST_to_IST(Ice%sCS%IST, Ice%fCS%IST, Ice%sCS%	      call copy_IST_to_IST(Ice%sCS%IST, Ice%fCS%IST, Ice%sCS%
           Ice%sCS%IG)						           Ice%sCS%IG)
    endif							    endif

  elseif (Ice%xtype == REDIST) then				  elseif (Ice%xtype == REDIST) then
    if (.not.associated(Ice%fCS) .and. .not.associated(Ice%sC	    if (.not.associated(Ice%fCS) .and. .not.associated(Ice%sC
      "Either the pointer to Ice%sCS or the pointer to Ice%fC	      "Either the pointer to Ice%sCS or the pointer to Ice%fC
      "associated in exchange_slow_to_fast_ice.")		      "associated in exchange_slow_to_fast_ice.")

    if (associated(Ice%fCS) .and. associated(Ice%sCS)) then	    if (associated(Ice%fCS) .and. associated(Ice%sCS)) then
      if (.not.associated(Ice%fCS%sOSS, Ice%sCS%sOSS)) &	      if (.not.associated(Ice%fCS%sOSS, Ice%sCS%sOSS)) &
        call redistribute_sOSS_to_sOSS(Ice%sCS%sOSS, Ice%fCS%	        call redistribute_sOSS_to_sOSS(Ice%sCS%sOSS, Ice%fCS%
                                       Ice%fast_domain, Ice%f	                                       Ice%fast_domain, Ice%f

      if (.not.associated(Ice%fCS%IST, Ice%sCS%IST)) &		      if (.not.associated(Ice%fCS%IST, Ice%sCS%IST)) &
        call redistribute_IST_to_IST(Ice%sCS%IST, Ice%fCS%IST	        call redistribute_IST_to_IST(Ice%sCS%IST, Ice%fCS%IST
                                     Ice%fast_domain)		                                     Ice%fast_domain)
    elseif (associated(Ice%fCS)) then				    elseif (associated(Ice%fCS)) then
      call redistribute_sOSS_to_sOSS(sOSS_null, Ice%fCS%sOSS,	      call redistribute_sOSS_to_sOSS(sOSS_null, Ice%fCS%sOSS,
                                     Ice%fast_domain, HI_out=	                                     Ice%fast_domain, HI_out=
      call redistribute_IST_to_IST(IST_null, Ice%fCS%IST, Ice	      call redistribute_IST_to_IST(IST_null, Ice%fCS%IST, Ice
                                   Ice%fast_domain)		                                   Ice%fast_domain)
    elseif (associated(Ice%sCS)) then				    elseif (associated(Ice%sCS)) then
      call redistribute_sOSS_to_sOSS(Ice%sCS%sOSS, sOSS_null,	      call redistribute_sOSS_to_sOSS(Ice%sCS%sOSS, sOSS_null,
                                     Ice%fast_domain)		                                     Ice%fast_domain)
      call redistribute_IST_to_IST(Ice%sCS%IST, IST_null, Ice	      call redistribute_IST_to_IST(Ice%sCS%IST, IST_null, Ice
                                   Ice%fast_domain)		                                   Ice%fast_domain)
    else							    else
      call SIS_error(FATAL, "Either the pointer to Ice%sCS or	      call SIS_error(FATAL, "Either the pointer to Ice%sCS or
                     "Ice%fCS must be associated in exchange_	                     "Ice%fCS must be associated in exchange_
    endif							    endif
  else								  else
    call SIS_error(FATAL, "exchange_slow_to_fast_ice called w	    call SIS_error(FATAL, "exchange_slow_to_fast_ice called w
  endif								  endif

  call cpu_clock_end(ice_clock_exchange) ; call cpu_clock_end	  call cpu_clock_end(ice_clock_exchange) ; call cpu_clock_end

end subroutine exchange_slow_to_fast_ice			end subroutine exchange_slow_to_fast_ice

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> This subroutine copies information from an ocean_ice_bound	!> This subroutine copies information from an ocean_ice_bound
!! slow part of an ice_data type, using a coupler-friendly in	!! slow part of an ice_data type, using a coupler-friendly in
subroutine unpack_ocean_ice_boundary(Ocean_boundary, Ice)	subroutine unpack_ocean_ice_boundary(Ocean_boundary, Ice)
  type(ocean_ice_boundary_type), &				  type(ocean_ice_boundary_type), &
    intent(inout) :: Ocean_boundary !< A structure containing	    intent(inout) :: Ocean_boundary !< A structure containing
                                    !! the ocean that is bein	                                    !! the ocean that is bein
  type(ice_data_type), &					  type(ice_data_type), &
    intent(inout) :: Ice            !< The publicly visible i	    intent(inout) :: Ice            !< The publicly visible i
                                    !! of which the ocean sur	                                    !! of which the ocean sur

  if (.not.associated(Ice%sCS)) call SIS_error(FATAL, &		  if (.not.associated(Ice%sCS)) call SIS_error(FATAL, &
      "The pointer to Ice%sCS must be associated in unpack_oc	      "The pointer to Ice%sCS must be associated in unpack_oc

  call unpack_ocn_ice_bdry(Ocean_boundary, Ice%sCS%OSS, Ice%s	  call unpack_ocn_ice_bdry(Ocean_boundary, Ice%sCS%OSS, Ice%s
                           Ice%sCS%specified_ice, Ice%ocean_f	                           Ice%sCS%specified_ice, Ice%ocean_f

  call translate_OSS_to_sOSS(Ice%sCS%OSS, Ice%sCS%IST, Ice%sC	  call translate_OSS_to_sOSS(Ice%sCS%OSS, Ice%sCS%IST, Ice%sC

end subroutine unpack_ocean_ice_boundary			end subroutine unpack_ocean_ice_boundary

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> This subroutine converts the information in a publicly vis	!> This subroutine converts the information in a publicly vis
!! ocean_ice_boundary_type into an internally visible ocean_s	!! ocean_ice_boundary_type into an internally visible ocean_s
!! variable.							!! variable.
subroutine unpack_ocn_ice_bdry(OIB, OSS, ITV, G, US, specifie	subroutine unpack_ocn_ice_bdry(OIB, OSS, ITV, G, US, specifie
  type(ocean_ice_boundary_type), intent(in)    :: OIB !< A ty	  type(ocean_ice_boundary_type), intent(in)    :: OIB !< A ty
                                                      !! are 	                                                      !! are 
  type(ocean_sfc_state_type),    intent(inout) :: OSS !< A st	  type(ocean_sfc_state_type),    intent(inout) :: OSS !< A st
                                                      !! the 	                                                      !! the 
  type(ice_thermo_type),         intent(in)    :: ITV !< The 	  type(ice_thermo_type),         intent(in)    :: ITV !< The 
  type(SIS_hor_grid_type),       intent(inout) :: G   !< The 	  type(SIS_hor_grid_type),       intent(inout) :: G   !< The 
  type(unit_scale_type),         intent(in)    :: US  !< A st	  type(unit_scale_type),         intent(in)    :: US  !< A st
  logical,                       intent(in)    :: specified_i	  logical,                       intent(in)    :: specified_i
  type(coupler_3d_bc_type),      intent(inout) :: ocean_field	  type(coupler_3d_bc_type),      intent(inout) :: ocean_field
                                                             	                                                             

  real, dimension(G%isd:G%ied, G%jsd:G%jed) :: u_nonsym, v_no	  real, dimension(G%isd:G%ied, G%jsd:G%jed) :: u_nonsym, v_no
  real, parameter :: T_0degC = 273.15 ! 0 degrees C in Kelvin	  real, parameter :: T_0degC = 273.15 ! 0 degrees C in Kelvin
  logical :: Cgrid_ocn						  logical :: Cgrid_ocn
  integer :: i, j, k, m, n, i2, j2, k2, isc, iec, jsc, jec, i	  integer :: i, j, k, m, n, i2, j2, k2, isc, iec, jsc, jec, i
!  integer :: iB_off, jB_off				      <
  integer :: isd, ied, jsd, jed					  integer :: isd, ied, jsd, jed

  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec		  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec
  isd = G%isd ; ied = G%ied ; jsd = G%jsd ; jed = G%jed		  isd = G%isd ; ied = G%ied ; jsd = G%jsd ; jed = G%jed
  i_off = LBOUND(OIB%t,1) - G%isc ; j_off = LBOUND(OIB%t,2) -	  i_off = LBOUND(OIB%t,1) - G%isc ; j_off = LBOUND(OIB%t,2) -
!  iB_off = LBOUND(OIB%u_sym,1) - G%isc ; jB_off = LBOUND(OIB <

  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c	  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c

  ! Pass the ocean state through ice on partition 0, unless u	  ! Pass the ocean state through ice on partition 0, unless u
  if (.not. specified_ice) then					  if (.not. specified_ice) then
    !$OMP parallel do default(shared) private(i2,j2)		    !$OMP parallel do default(shared) private(i2,j2)
    do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off	    do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off
      OSS%SST_C(i,j) = US%degC_to_C * (OIB%t(i2,j2) - T_0degC	      OSS%SST_C(i,j) = US%degC_to_C * (OIB%t(i2,j2) - T_0degC
    enddo ; enddo						    enddo ; enddo
  endif								  endif

  !$OMP parallel do default(shared) private(i2,j2)		  !$OMP parallel do default(shared) private(i2,j2)
  do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off	  do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off
    OSS%s_surf(i,j) = US%ppt_to_S*OIB%s(i2,j2)			    OSS%s_surf(i,j) = US%ppt_to_S*OIB%s(i2,j2)
    OSS%T_fr_ocn(i,j) = T_Freeze(OSS%s_surf(i,j), ITV)		    OSS%T_fr_ocn(i,j) = T_Freeze(OSS%s_surf(i,j), ITV)
    OSS%bheat(i,j) = OSS%kmelt*(OSS%SST_C(i,j) - OSS%T_fr_ocn	    OSS%bheat(i,j) = OSS%kmelt*(OSS%SST_C(i,j) - OSS%T_fr_ocn
    OSS%frazil(i,j) = US%W_m2_to_QRZ_T*US%s_to_T*OIB%frazil(i	    OSS%frazil(i,j) = US%W_m2_to_QRZ_T*US%s_to_T*OIB%frazil(i
    OSS%sea_lev(i,j) = US%m_to_Z*OIB%sea_level(i2,j2)		    OSS%sea_lev(i,j) = US%m_to_Z*OIB%sea_level(i2,j2)
  enddo ; enddo							  enddo ; enddo

  Cgrid_ocn = (allocated(OSS%u_ocn_C) .and. allocated(OSS%v_o	  Cgrid_ocn = (allocated(OSS%u_ocn_C) .and. allocated(OSS%v_o

  if (.not. OIB%use_oib_sym) then			      |	  ! Unpack the ocean surface velocities.
    ! Unpack the ocean surface velocities.		      |	  if (OIB%stagger == AGRID) then
    if (OIB%stagger == AGRID) then			      |	    u_nonsym(:,:) = 0.0 ; v_nonsym(:,:) = 0.0
							      >	    do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off
							      >	      u_nonsym(i,j) = US%m_s_to_L_T*OIB%u(i2,j2) ; v_nonsym(i
							      >	    enddo ; enddo
							      >	    call pass_vector(u_nonsym, v_nonsym, G%Domain_aux, stagge
							      >
							      >	    if (Cgrid_ocn) then
							      >	      do j=jsc,jec ; do I=isc-1,iec
							      >	        OSS%u_ocn_C(I,j) = 0.5*(u_nonsym(i,j) + u_nonsym(i+1,
							      >	      enddo ; enddo
							      >	      do J=jsc-1,jec ; do i=isc,iec
							      >	        OSS%v_ocn_C(i,J) = 0.5*(v_nonsym(i,j) + v_nonsym(i,j+
							      >	      enddo ; enddo
							      >	    else
							      >	      do J=jsc-1,jec ; do I=isc-1,iec
							      >	        OSS%u_ocn_B(I,J) = 0.25*((u_nonsym(i,j) + u_nonsym(i+
							      >	                               (u_nonsym(i+1,j) + u_nonsym(i,
							      >	        OSS%v_ocn_B(I,J) = 0.25*((v_nonsym(i,j) + v_nonsym(i+
							      >	                               (v_nonsym(i+1,j) + v_nonsym(i,
							      >	      enddo ; enddo
							      >	    endif
							      >
							      >	  elseif (OIB%stagger == BGRID_NE) then
							      >	    if (Cgrid_ocn) then
      u_nonsym(:,:) = 0.0 ; v_nonsym(:,:) = 0.0			      u_nonsym(:,:) = 0.0 ; v_nonsym(:,:) = 0.0
      do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_o	      do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_o
        u_nonsym(i,j) = US%m_s_to_L_T*OIB%u(i2,j2) ; v_nonsym	        u_nonsym(i,j) = US%m_s_to_L_T*OIB%u(i2,j2) ; v_nonsym
      enddo ; enddo						      enddo ; enddo
      call pass_vector(u_nonsym, v_nonsym, G%Domain_aux, stag |	      call pass_vector(u_nonsym, v_nonsym, G%Domain_aux, stag

      if (Cgrid_ocn) then				      |	      do j=jsc,jec ; do I=isc-1,iec
        do j=jsc,jec ; do I=isc-1,iec			      |	        OSS%u_ocn_C(I,j) = 0.5*(u_nonsym(I,J) + u_nonsym(I,J-
          OSS%u_ocn_C(I,j) = 0.5*(u_nonsym(i,j) + u_nonsym(i+ |	      enddo ; enddo
        enddo ; enddo					      |	      do J=jsc-1,jec ; do i=isc,iec
        do J=jsc-1,jec ; do i=isc,iec			      |	        OSS%v_ocn_C(i,J) = 0.5*(v_nonsym(I,J) + v_nonsym(I-1,
          OSS%v_ocn_C(i,J) = 0.5*(v_nonsym(i,j) + v_nonsym(i, |	      enddo ; enddo
        enddo ; enddo					      <
      else						      <
        do J=jsc-1,jec ; do I=isc-1,iec			      <
          OSS%u_ocn_B(I,J) = 0.25*((u_nonsym(i,j) + u_nonsym( <
                                 (u_nonsym(i+1,j) + u_nonsym( <
          OSS%v_ocn_B(I,J) = 0.25*((v_nonsym(i,j) + v_nonsym( <
                                 (v_nonsym(i+1,j) + v_nonsym( <
        enddo ; enddo					      <
      endif						      <
							      <
    elseif (OIB%stagger == BGRID_NE) then		      <
      if (Cgrid_ocn) then				      <
        u_nonsym(:,:) = 0.0 ; v_nonsym(:,:) = 0.0	      <
        do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j <
          u_nonsym(i,j) = US%m_s_to_L_T*OIB%u(i2,j2) ; v_nons <
        enddo ; enddo					      <
        call pass_vector(u_nonsym, v_nonsym, G%Domain_aux, st <
							      <
        do j=jsc,jec ; do I=isc-1,iec			      <
          OSS%u_ocn_C(I,j) = 0.5*(u_nonsym(I,J) + u_nonsym(I, <
        enddo ; enddo					      <
        do J=jsc-1,jec ; do i=isc,iec			      <
          OSS%v_ocn_C(i,J) = 0.5*(v_nonsym(I,J) + v_nonsym(I- <
        enddo ; enddo					      <
      else						      <
        do J=jsc,jec ; do I=isc,iec ; i2 = i+i_off ; j2 = j+j <
          OSS%u_ocn_B(I,J) = US%m_s_to_L_T*OIB%u(i2,j2)	      <
          OSS%v_ocn_B(I,J) = US%m_s_to_L_T*OIB%v(i2,j2)	      <
        enddo ; enddo					      <
        if (G%symmetric) &				      <
          call fill_symmetric_edges(OSS%u_ocn_B, OSS%v_ocn_B, <
      endif						      <
							      <
    elseif (OIB%stagger == CGRID_NE) then		      <
      if (Cgrid_ocn) then				      <
        do j=jsc,jec ; do I=isc,iec ; i2 = i+i_off ; j2 = j+j <
          OSS%u_ocn_C(I,j) = US%m_s_to_L_T*OIB%u(i2,j2)	      <
        enddo ; enddo					      <
        do J=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j <
          OSS%v_ocn_C(i,J) = US%m_s_to_L_T*OIB%v(i2,j2)	      <
        enddo ; enddo					      <
        if (G%symmetric) &				      <
          call fill_symmetric_edges(OSS%u_ocn_C, OSS%v_ocn_C, <
      else						      <
        u_nonsym(:,:) = 0.0 ; v_nonsym(:,:) = 0.0	      <
        do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j <
          u_nonsym(I,j) = US%m_s_to_L_T*OIB%u(i2,j2) ; v_nons <
        enddo ; enddo					      <
        call pass_vector(u_nonsym, v_nonsym, G%Domain_aux, st <
        do J=jsc-1,jec ; do I=isc-1,iec			      <
          OSS%u_ocn_B(I,J) = 0.5*(u_nonsym(I,j) + u_nonsym(I, <
          OSS%v_ocn_B(I,J) = 0.5*(v_nonsym(i,J) + v_nonsym(i+ <
        enddo ; enddo					      <
      endif						      <
    else							    else
      call SIS_error(FATAL, "unpack_ocn_ice_bdry: Unrecognize |	      do J=jsc,jec ; do I=isc,iec ; i2 = i+i_off ; j2 = j+j_o
							      >	        OSS%u_ocn_B(I,J) = US%m_s_to_L_T*OIB%u(i2,j2)
							      >	        OSS%v_ocn_B(I,J) = US%m_s_to_L_T*OIB%v(i2,j2)
							      >	      enddo ; enddo
							      >	      if (G%symmetric) &
							      >	        call fill_symmetric_edges(OSS%u_ocn_B, OSS%v_ocn_B, G
    endif							    endif
  else ! OIB%use_oib_sym == true so use symmetric u and v     |
    if (OIB%stagger == CGRID_NE) then			      |	  elseif (OIB%stagger == CGRID_NE) then
      if (Cgrid_ocn) then				      |	    if (Cgrid_ocn) then
        do j=jsc,jec ; do I=isc-1,iec ; i2 = I+i_off ; j2 = j |	      do j=jsc,jec ; do I=isc,iec ; i2 = i+i_off ; j2 = j+j_o
          OSS%u_ocn_C(I,j) = US%m_s_to_L_T*OIB%u_sym(i2,j2)   |	        OSS%u_ocn_C(I,j) = US%m_s_to_L_T*OIB%u(i2,j2)
        enddo ; enddo					      |	      enddo ; enddo
        do J=jsc-1,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = J |	      do J=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_o
          OSS%v_ocn_C(i,J) = US%m_s_to_L_T*OIB%v_sym(i2,j2)   |	        OSS%v_ocn_C(i,J) = US%m_s_to_L_T*OIB%v(i2,j2)
        enddo ; enddo					      |	      enddo ; enddo
!        OSS%u_ocn_C = US%m_s_to_L_T*OIB%u_sym		      |	      if (G%symmetric) &
!        OSS%v_ocn_C = US%m_s_to_L_T*OIB%v_sym		      |	        call fill_symmetric_edges(OSS%u_ocn_C, OSS%v_ocn_C, G
      else						      <
        call SIS_error(FATAL, "unpack_ocn_ice_bdry: must be u <
      endif						      <
    else							    else
      call SIS_error(FATAL, "unpack_ocn_ice_bdry: must use OI |	      u_nonsym(:,:) = 0.0 ; v_nonsym(:,:) = 0.0
							      >	      do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_o
							      >	        u_nonsym(I,j) = US%m_s_to_L_T*OIB%u(i2,j2) ; v_nonsym
							      >	      enddo ; enddo
							      >	      call pass_vector(u_nonsym, v_nonsym, G%Domain_aux, stag
							      >	      do J=jsc-1,jec ; do I=isc-1,iec
							      >	        OSS%u_ocn_B(I,J) = 0.5*(u_nonsym(I,j) + u_nonsym(I,j+
							      >	        OSS%v_ocn_B(I,J) = 0.5*(v_nonsym(i,J) + v_nonsym(i+1,
							      >	      enddo ; enddo
    endif							    endif
  endif ! OIB%use_oib_sym 				      |	  else
							      >	    call SIS_error(FATAL, "unpack_ocn_ice_bdry: Unrecognized 
							      >	  endif

  ! Fill in the halo values.					  ! Fill in the halo values.
  if (Cgrid_ocn) then						  if (Cgrid_ocn) then
    if (.not.OIB%use_oib_sym) then			      |	    call pass_vector(OSS%u_ocn_C, OSS%v_ocn_C, G%Domain, stag
      call pass_vector(OSS%u_ocn_C, OSS%v_ocn_C, G%Domain, st <
    endif						      <
  else								  else
    call pass_vector(OSS%u_ocn_B, OSS%v_ocn_B, G%Domain, stag	    call pass_vector(OSS%u_ocn_B, OSS%v_ocn_B, G%Domain, stag
  endif								  endif
  call pass_var(OSS%sea_lev, G%Domain)				  call pass_var(OSS%sea_lev, G%Domain)

! Transfer the ocean state for extra tracer fluxes.		! Transfer the ocean state for extra tracer fluxes.
  call coupler_type_spawn(OIB%fields, OSS%tr_fields, (/isd, i	  call coupler_type_spawn(OIB%fields, OSS%tr_fields, (/isd, i
                          (/jsd, jsc, jec, jed/), as_needed=.	                          (/jsd, jsc, jec, jed/), as_needed=.
  call coupler_type_copy_data(OIB%fields, OSS%tr_fields)	  call coupler_type_copy_data(OIB%fields, OSS%tr_fields)

  call cpu_clock_end(ice_clock_slow) ; call cpu_clock_end(ice	  call cpu_clock_end(ice_clock_slow) ; call cpu_clock_end(ice

end subroutine unpack_ocn_ice_bdry				end subroutine unpack_ocn_ice_bdry

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> set_ice_surface_fields prepares the ice surface state for 	!> set_ice_surface_fields prepares the ice surface state for 
!! physics and does precalculation of ice radiative propertie	!! physics and does precalculation of ice radiative propertie
subroutine set_ice_surface_fields(Ice)				subroutine set_ice_surface_fields(Ice)
  type(ice_data_type), intent(inout) :: Ice !< The publicly v	  type(ice_data_type), intent(inout) :: Ice !< The publicly v
                                            !! surface proper	                                            !! surface proper

  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c	  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c
  if (.not.associated(Ice%fCS)) call SIS_error(FATAL, &		  if (.not.associated(Ice%fCS)) call SIS_error(FATAL, &
      "The pointer to Ice%fCS must be associated in set_ice_s	      "The pointer to Ice%fCS must be associated in set_ice_s

  call set_ice_surface_state(Ice, Ice%fCS%IST, Ice%fCS%sOSS, 	  call set_ice_surface_state(Ice, Ice%fCS%IST, Ice%fCS%sOSS, 
                             Ice%fCS%FIA, Ice%fCS%G, Ice%fCS%	                             Ice%fCS%FIA, Ice%fCS%G, Ice%fCS%

  call cpu_clock_end(ice_clock_fast) ; call cpu_clock_end(ice	  call cpu_clock_end(ice_clock_fast) ; call cpu_clock_end(ice
end subroutine set_ice_surface_fields				end subroutine set_ice_surface_fields

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> set_ice_surface_state prepares the surface state for atmos	!> set_ice_surface_state prepares the surface state for atmos
subroutine set_ice_surface_state(Ice, IST, OSS, Rad, FIA, G, 	subroutine set_ice_surface_state(Ice, IST, OSS, Rad, FIA, G, 
  type(ice_data_type),        intent(inout) :: Ice !< The pub	  type(ice_data_type),        intent(inout) :: Ice !< The pub
  type(ice_state_type),       intent(in)    :: IST !< A type 	  type(ice_state_type),       intent(in)    :: IST !< A type 
  type(simple_OSS_type),      intent(in)    :: OSS !< A struc	  type(simple_OSS_type),      intent(in)    :: OSS !< A struc
                                                   !! the oce	                                                   !! the oce
  type(ice_rad_type),         intent(inout) :: Rad !< A struc	  type(ice_rad_type),         intent(inout) :: Rad !< A struc
                                                   !! reflect	                                                   !! reflect
  type(fast_ice_avg_type),    intent(inout) :: FIA !< A type 	  type(fast_ice_avg_type),    intent(inout) :: FIA !< A type 
                                                   !! (mostly	                                                   !! (mostly
  type(SIS_hor_grid_type),    intent(inout) :: G   !< The hor	  type(SIS_hor_grid_type),    intent(inout) :: G   !< The hor
  type(unit_scale_type),      intent(in)    :: US  !< A struc	  type(unit_scale_type),      intent(in)    :: US  !< A struc
  type(ice_grid_type),        intent(in)    :: IG  !< The sea	  type(ice_grid_type),        intent(in)    :: IG  !< The sea
  type(SIS_fast_CS),          intent(inout) :: fCS !< The fas	  type(SIS_fast_CS),          intent(inout) :: fCS !< The fas

  real, dimension(G%isc:G%iec,G%jsc:G%jec) :: m_ice_tot !< Th	  real, dimension(G%isc:G%iec,G%jsc:G%jec) :: m_ice_tot !< Th
  real, dimension(IG%NkIce) :: sw_abs_lay ! The fraction of t	  real, dimension(IG%NkIce) :: sw_abs_lay ! The fraction of t
                                          ! absorbed in each 	                                          ! absorbed in each 
  real, dimension(size(FIA%flux_sw_top,4)) :: &			  real, dimension(size(FIA%flux_sw_top,4)) :: &
    albedos        ! The albedos for the various wavelength a	    albedos        ! The albedos for the various wavelength a
                   ! for the current partition, non-dimension	                   ! for the current partition, non-dimension
  real :: u, v     ! Ice velocity components [m s-1]		  real :: u, v     ! Ice velocity components [m s-1]

  integer :: i, j, k, m, n, i2, j2, k2, isc, iec, jsc, jec, n	  integer :: i, j, k, m, n, i2, j2, k2, isc, iec, jsc, jec, n
  integer :: index						  integer :: index
  real, parameter :: T_0degC = 273.15 ! 0 degrees C in Kelvin	  real, parameter :: T_0degC = 273.15 ! 0 degrees C in Kelvin

  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec ; nca	  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec ; nca
  i_off = LBOUND(Ice%t_surf,1) - G%isc ; j_off = LBOUND(Ice%t	  i_off = LBOUND(Ice%t_surf,1) - G%isc ; j_off = LBOUND(Ice%t

  if (fCS%bounds_check) &					  if (fCS%bounds_check) &
    call IST_bounds_check(IST, G, US, IG, "Start of set_ice_s	    call IST_bounds_check(IST, G, US, IG, "Start of set_ice_s

  if (fCS%debug) then						  if (fCS%debug) then
    call IST_chksum("Start set_ice_surface_state", IST, G, fC	    call IST_chksum("Start set_ice_surface_state", IST, G, fC
    call Ice_public_type_chksum("Start set_ice_surface_state"	    call Ice_public_type_chksum("Start set_ice_surface_state"
                                check_fast=.false., check_rou	                                check_fast=.false., check_rou
  endif								  endif

  m_ice_tot(:,:) = 0.0						  m_ice_tot(:,:) = 0.0
  !$OMP parallel do default(none) shared(isc,iec,jsc,jec,G,IS	  !$OMP parallel do default(none) shared(isc,iec,jsc,jec,G,IS
  do j=jsc,jec ; do k=1,ncat ; do i=isc,iec			  do j=jsc,jec ; do k=1,ncat ; do i=isc,iec
    FIA%tmelt(i,j,k) = 0.0 ; FIA%bmelt(i,j,k) = 0.0		    FIA%tmelt(i,j,k) = 0.0 ; FIA%bmelt(i,j,k) = 0.0
    m_ice_tot(i,j) = m_ice_tot(i,j) + IST%mH_ice(i,j,k) * IST	    m_ice_tot(i,j) = m_ice_tot(i,j) + IST%mH_ice(i,j,k) * IST
  enddo ; enddo ; enddo						  enddo ; enddo ; enddo

  if (.not.fCS%Eulerian_tsurf) then				  if (.not.fCS%Eulerian_tsurf) then
    do k=1,ncat ; do j=jsc,jec ; do i=isc,iec			    do k=1,ncat ; do j=jsc,jec ; do i=isc,iec
      Rad%t_skin(i,j,k) = IST%t_surf(i,j,k) - IST%T_0degC	      Rad%t_skin(i,j,k) = IST%t_surf(i,j,k) - IST%T_0degC
    enddo ; enddo ; enddo					    enddo ; enddo ; enddo
  endif								  endif

  ! Determine the sea-ice optical properties.			  ! Determine the sea-ice optical properties.

  !   These initialization calls for ice-free categories are 	  !   These initialization calls for ice-free categories are 
  ! needed because these arrays are only used where there is 	  ! needed because these arrays are only used where there is 
  !   The following lines can be uncommented without changing	  !   The following lines can be uncommented without changing
  ! Rad%sw_abs_sfc(:,:,:) = 0.0 ; Rad%sw_abs_snow(:,:,:) = 0.	  ! Rad%sw_abs_sfc(:,:,:) = 0.0 ; Rad%sw_abs_snow(:,:,:) = 0.
  ! Rad%sw_abs_ice(:,:,:,:) = 0.0 ; Rad%sw_abs_ocn(:,:,:) = 0	  ! Rad%sw_abs_ice(:,:,:,:) = 0.0 ; Rad%sw_abs_ocn(:,:,:) = 0
  ! Rad%sw_abs_int(:,:,:) = 0.0					  ! Rad%sw_abs_int(:,:,:) = 0.0
  ! Ice%albedo(:,:,:) = 0.0					  ! Ice%albedo(:,:,:) = 0.0
  ! Ice%albedo_vis_dir(:,:,:) = 0.0 ; Ice%albedo_vis_dif(:,:,	  ! Ice%albedo_vis_dir(:,:,:) = 0.0 ; Ice%albedo_vis_dif(:,:,
  ! Ice%albedo_nir_dir(:,:,:) = 0.0 ; Ice%albedo_nir_dif(:,:,	  ! Ice%albedo_nir_dir(:,:,:) = 0.0 ; Ice%albedo_nir_dif(:,:,

  ! Set the initial ocean albedos, either using coszen_nextra	  ! Set the initial ocean albedos, either using coszen_nextra
  if (Rad%do_sun_angle_for_alb) then				  if (Rad%do_sun_angle_for_alb) then
    call set_ocean_albedo_from_astronomy(Ice, G, fCS%Time, fC	    call set_ocean_albedo_from_astronomy(Ice, G, fCS%Time, fC
  else								  else
    call set_ocean_albedo_from_coszen(Ice, G, Rad%coszen_next	    call set_ocean_albedo_from_coszen(Ice, G, Rad%coszen_next
  endif								  endif

  !$OMP parallel do default(shared) private(i2,j2,k2,sw_abs_l	  !$OMP parallel do default(shared) private(i2,j2,k2,sw_abs_l
  do j=jsc,jec ; do k=1,ncat ; do i=isc,iec			  do j=jsc,jec ; do k=1,ncat ; do i=isc,iec
    i2 = i+i_off ; j2 = j+j_off ; k2 = k+1			    i2 = i+i_off ; j2 = j+j_off ; k2 = k+1
    if (IST%part_size(i,j,k)*IST%MH_ice(i,j,k) > 0.0) then	    if (IST%part_size(i,j,k)*IST%MH_ice(i,j,k) > 0.0) then
      call ice_optics_SIS2(IST%mH_pond(i,j,k), IST%mH_snow(i,	      call ice_optics_SIS2(IST%mH_pond(i,j,k), IST%mH_snow(i,
               Rad%t_skin(i,j,k), OSS%T_fr_ocn(i,j), IG%NkIce	               Rad%t_skin(i,j,k), OSS%T_fr_ocn(i,j), IG%NkIce
               Rad%sw_abs_sfc(i,j,k), Rad%sw_abs_snow(i,j,k),	               Rad%sw_abs_sfc(i,j,k), Rad%sw_abs_snow(i,j,k),
               sw_abs_lay, Rad%sw_abs_ocn(i,j,k), Rad%sw_abs_	               sw_abs_lay, Rad%sw_abs_ocn(i,j,k), Rad%sw_abs_
               US, fCS%optics_CSp, IST%ITV, coszen_in=Rad%cos	               US, fCS%optics_CSp, IST%ITV, coszen_in=Rad%cos
      Ice%albedo_vis_dir(i2,j2,k2) = albedos(VIS_DIR)		      Ice%albedo_vis_dir(i2,j2,k2) = albedos(VIS_DIR)
      Ice%albedo_vis_dif(i2,j2,k2) = albedos(VIS_DIF)		      Ice%albedo_vis_dif(i2,j2,k2) = albedos(VIS_DIF)
      Ice%albedo_nir_dir(i2,j2,k2) = albedos(NIR_DIR)		      Ice%albedo_nir_dir(i2,j2,k2) = albedos(NIR_DIR)
      Ice%albedo_nir_dif(i2,j2,k2) = albedos(NIR_DIF)		      Ice%albedo_nir_dif(i2,j2,k2) = albedos(NIR_DIF)

      do m=1,IG%NkIce ; Rad%sw_abs_ice(i,j,k,m) = sw_abs_lay(	      do m=1,IG%NkIce ; Rad%sw_abs_ice(i,j,k,m) = sw_abs_lay(

      !Niki: Is the following correct for diagnostics?		      !Niki: Is the following correct for diagnostics?
      !###  This calculation of the "average" albedo should b	      !###  This calculation of the "average" albedo should b
      ! with a calculation that weights the averaging by the 	      ! with a calculation that weights the averaging by the 
      ! shortwave radiation in each wavelength and orientatio	      ! shortwave radiation in each wavelength and orientatio
      ! since this is only used for diagnostic purposes, maki	      ! since this is only used for diagnostic purposes, maki
      ! might not be too urgent. -RWH				      ! might not be too urgent. -RWH
      Ice%albedo(i2,j2,k2) = (Ice%albedo_vis_dir(i2,j2,k2)+Ic	      Ice%albedo(i2,j2,k2) = (Ice%albedo_vis_dir(i2,j2,k2)+Ic
                        +Ice%albedo_vis_dif(i2,j2,k2)+Ice%alb	                        +Ice%albedo_vis_dif(i2,j2,k2)+Ice%alb
    else ! Zero the albedos and absorbed shortwave radiation 	    else ! Zero the albedos and absorbed shortwave radiation 
      Rad%sw_abs_sfc(i,j,k) = 0.0				      Rad%sw_abs_sfc(i,j,k) = 0.0
      Rad%sw_abs_snow(i,j,k) = 0.0				      Rad%sw_abs_snow(i,j,k) = 0.0
      Rad%sw_abs_int(i,j,k) = 0.0				      Rad%sw_abs_int(i,j,k) = 0.0
      Rad%sw_abs_ocn(i,j,k) = 0.0				      Rad%sw_abs_ocn(i,j,k) = 0.0
      Ice%albedo_vis_dir(i2,j2,k2) = 0.0			      Ice%albedo_vis_dir(i2,j2,k2) = 0.0
      Ice%albedo_vis_dif(i2,j2,k2) = 0.0			      Ice%albedo_vis_dif(i2,j2,k2) = 0.0
      Ice%albedo_nir_dir(i2,j2,k2) = 0.0			      Ice%albedo_nir_dir(i2,j2,k2) = 0.0
      Ice%albedo_nir_dif(i2,j2,k2) = 0.0			      Ice%albedo_nir_dif(i2,j2,k2) = 0.0
      Ice%albedo(i2,j2,k2) = 0.0				      Ice%albedo(i2,j2,k2) = 0.0
    endif							    endif
  enddo ; enddo ; enddo						  enddo ; enddo ; enddo

  !$OMP parallel do default(shared)				  !$OMP parallel do default(shared)
  do j=jsc,jec							  do j=jsc,jec
    do k=1,ncat ; do i=isc,iec					    do k=1,ncat ; do i=isc,iec
      Rad%Tskin_rad(i,j,k) = Rad%t_skin(i,j,k)			      Rad%Tskin_rad(i,j,k) = Rad%t_skin(i,j,k)
    enddo ; enddo						    enddo ; enddo
    do i=isc,iec						    do i=isc,iec
      Rad%coszen_lastrad(i,j) = Rad%coszen_nextrad(i,j)		      Rad%coszen_lastrad(i,j) = Rad%coszen_nextrad(i,j)
    enddo							    enddo
  enddo								  enddo

  if (fCS%bounds_check) &					  if (fCS%bounds_check) &
    call IST_bounds_check(IST, G, US, IG, "Midpoint set_ice_s	    call IST_bounds_check(IST, G, US, IG, "Midpoint set_ice_s

  ! Copy the surface temperatures into the externally visible	  ! Copy the surface temperatures into the externally visible
!$OMP parallel do default(none) shared(isc,iec,jsc,jec,IST,Ic	!$OMP parallel do default(none) shared(isc,iec,jsc,jec,IST,Ic
!$OMP                          private(i2,j2)			!$OMP                          private(i2,j2)
  do j=jsc,jec ; do i=isc,iec					  do j=jsc,jec ; do i=isc,iec
    i2 = i+i_off ; j2 = j+j_off					    i2 = i+i_off ; j2 = j+j_off
    Ice%t_surf(i2,j2,1) = US%C_to_degC*OSS%SST_C(i,j) + T_0de	    Ice%t_surf(i2,j2,1) = US%C_to_degC*OSS%SST_C(i,j) + T_0de
    Ice%part_size(i2,j2,1) = IST%part_size(i,j,0)		    Ice%part_size(i2,j2,1) = IST%part_size(i,j,0)
  enddo ; enddo							  enddo ; enddo
!$OMP parallel do default(none) shared(isc,iec,jsc,jec,IST,Ra	!$OMP parallel do default(none) shared(isc,iec,jsc,jec,IST,Ra
!$OMP                          private(i2,j2,k2)		!$OMP                          private(i2,j2,k2)
  do j=jsc,jec ; do k=1,ncat ; do i=isc,iec			  do j=jsc,jec ; do k=1,ncat ; do i=isc,iec
      i2 = i+i_off ; j2 = j+j_off ; k2 = k+1			      i2 = i+i_off ; j2 = j+j_off ; k2 = k+1
      Ice%t_surf(i2,j2,k2) = US%C_to_degC*Rad%t_skin(i,j,k) +	      Ice%t_surf(i2,j2,k2) = US%C_to_degC*Rad%t_skin(i,j,k) +
      Ice%part_size(i2,j2,k2) = IST%part_size(i,j,k)		      Ice%part_size(i2,j2,k2) = IST%part_size(i,j,k)
    enddo ; enddo						    enddo ; enddo
  enddo								  enddo

  ! Put ocean salinity and ocean and ice velocities into Ice%	  ! Put ocean salinity and ocean and ice velocities into Ice%
  !$OMP parallel do default(shared) private(i2,j2)		  !$OMP parallel do default(shared) private(i2,j2)
  do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off	  do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off
    Ice%u_surf(i2,j2,1) = US%L_T_to_m_s*OSS%u_ocn_A(i,j)	    Ice%u_surf(i2,j2,1) = US%L_T_to_m_s*OSS%u_ocn_A(i,j)
    Ice%v_surf(i2,j2,1) = US%L_T_to_m_s*OSS%v_ocn_A(i,j)	    Ice%v_surf(i2,j2,1) = US%L_T_to_m_s*OSS%v_ocn_A(i,j)
    Ice%u_surf(i2,j2,2) = US%L_T_to_m_s*OSS%u_ice_A(i,j)	    Ice%u_surf(i2,j2,2) = US%L_T_to_m_s*OSS%u_ice_A(i,j)
    Ice%v_surf(i2,j2,2) = US%L_T_to_m_s*OSS%v_ice_A(i,j)	    Ice%v_surf(i2,j2,2) = US%L_T_to_m_s*OSS%v_ice_A(i,j)
    Ice%s_surf(i2,j2) = US%S_to_ppt*OSS%s_surf(i,j)		    Ice%s_surf(i2,j2) = US%S_to_ppt*OSS%s_surf(i,j)
  enddo ; enddo							  enddo ; enddo

  if (fCS%debug) then						  if (fCS%debug) then
    call chksum(Ice%u_surf(:,:,1), "Intermed Ice%u_surf(1)")	    call chksum(Ice%u_surf(:,:,1), "Intermed Ice%u_surf(1)")
    call chksum(Ice%v_surf(:,:,1), "Intermed Ice%v_surf(1)")	    call chksum(Ice%v_surf(:,:,1), "Intermed Ice%v_surf(1)")
    call chksum(Ice%u_surf(:,:,2), "Intermed Ice%u_surf(2)")	    call chksum(Ice%u_surf(:,:,2), "Intermed Ice%u_surf(2)")
    call chksum(Ice%v_surf(:,:,2), "Intermed Ice%v_surf(2)")	    call chksum(Ice%v_surf(:,:,2), "Intermed Ice%v_surf(2)")
    call chksum(G%mask2dT(isc:iec,jsc:jec), "Intermed G%mask2	    call chksum(G%mask2dT(isc:iec,jsc:jec), "Intermed G%mask2
!   if (allocated(OSS%u_ocn_C) .and. allocated(OSS%v_ocn_C)) 	!   if (allocated(OSS%u_ocn_C) .and. allocated(OSS%v_ocn_C)) 
!     call uvchksum(OSS%u_ocn_C, "OSS%u_ocn_C", &		!     call uvchksum(OSS%u_ocn_C, "OSS%u_ocn_C", &
!                   OSS%v_ocn_C, "OSS%v_ocn_C", G%HI, haloshi	!                   OSS%v_ocn_C, "OSS%v_ocn_C", G%HI, haloshi
!   if (allocated(OSS%u_ocn_B)) &				!   if (allocated(OSS%u_ocn_B)) &
!     call Bchksum(OSS%u_ocn_B, "OSS%u_ocn_B", G%HI, haloshif	!     call Bchksum(OSS%u_ocn_B, "OSS%u_ocn_B", G%HI, haloshif
!   if (allocated(OSS%v_ocn_B)) &				!   if (allocated(OSS%v_ocn_B)) &
!     call Bchksum(OSS%v_ocn_B, "OSS%v_ocn_B", G%HI, haloshif	!     call Bchksum(OSS%v_ocn_B, "OSS%v_ocn_B", G%HI, haloshif
    call chksum(G%sin_rot(isc:iec,jsc:jec), "G%sin_rot")	    call chksum(G%sin_rot(isc:iec,jsc:jec), "G%sin_rot")
    call chksum(G%cos_rot(isc:iec,jsc:jec), "G%cos_rot")	    call chksum(G%cos_rot(isc:iec,jsc:jec), "G%cos_rot")
  endif								  endif

  ! Rotate the velocities from the ocean coordinates to lat/l	  ! Rotate the velocities from the ocean coordinates to lat/l
  do k2=1,2 ; do j=jsc,jec ; do i=isc,iec			  do k2=1,2 ; do j=jsc,jec ; do i=isc,iec
    i2 = i+i_off ; j2 = j+j_off					    i2 = i+i_off ; j2 = j+j_off
    u = Ice%u_surf(i2,j2,k2) ; v = Ice%v_surf(i2,j2,k2)		    u = Ice%u_surf(i2,j2,k2) ; v = Ice%v_surf(i2,j2,k2)
    Ice%u_surf(i2,j2,k2) =  u*G%cos_rot(i,j)+v*G%sin_rot(i,j)	    Ice%u_surf(i2,j2,k2) =  u*G%cos_rot(i,j)+v*G%sin_rot(i,j)
    Ice%v_surf(i2,j2,k2) =  v*G%cos_rot(i,j)-u*G%sin_rot(i,j)	    Ice%v_surf(i2,j2,k2) =  v*G%cos_rot(i,j)-u*G%sin_rot(i,j)
  enddo ; enddo ; enddo						  enddo ; enddo ; enddo
  do k2=3,ncat+1						  do k2=3,ncat+1
    Ice%u_surf(:,:,k2) = Ice%u_surf(:,:,2)  ! same ice flow o	    Ice%u_surf(:,:,k2) = Ice%u_surf(:,:,2)  ! same ice flow o
    Ice%v_surf(:,:,k2) = Ice%v_surf(:,:,2)  !			    Ice%v_surf(:,:,k2) = Ice%v_surf(:,:,2)  !
  enddo								  enddo
  if (fCS%debug) then						  if (fCS%debug) then
    do k2=1,ncat+1						    do k2=1,ncat+1
      call chksum(Ice%u_surf(:,:,k2), "End Ice%u_surf(k2)")	      call chksum(Ice%u_surf(:,:,k2), "End Ice%u_surf(k2)")
      call chksum(Ice%v_surf(:,:,k2), "End Ice%v_surf(k2)")	      call chksum(Ice%v_surf(:,:,k2), "End Ice%v_surf(k2)")
    enddo							    enddo
  endif								  endif

  ! Copy over the additional tracer fields into the open-ocea	  ! Copy over the additional tracer fields into the open-ocea
  ! the Ice%ocean_fields structure.				  ! the Ice%ocean_fields structure.
  call coupler_type_copy_data(OSS%tr_fields, Ice%ocean_fields	  call coupler_type_copy_data(OSS%tr_fields, Ice%ocean_fields

  if (fCS%debug) then						  if (fCS%debug) then
    call IST_chksum("End set_ice_surface_state", IST, G, fCS%	    call IST_chksum("End set_ice_surface_state", IST, G, fCS%
    call Ice_public_type_chksum("End set_ice_surface_state", 	    call Ice_public_type_chksum("End set_ice_surface_state", 
  endif								  endif

  if (fCS%bounds_check) &					  if (fCS%bounds_check) &
    call Ice_public_type_bounds_check(Ice, G, "End set_ice_su	    call Ice_public_type_bounds_check(Ice, G, "End set_ice_su

end subroutine set_ice_surface_state				end subroutine set_ice_surface_state

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> update_ice_model_fast records fluxes (in Ice) and calculat	!> update_ice_model_fast records fluxes (in Ice) and calculat
!!    on the (fast) atmospheric timestep			!!    on the (fast) atmospheric timestep
subroutine update_ice_model_fast( Atmos_boundary, Ice )		subroutine update_ice_model_fast( Atmos_boundary, Ice )
  type(ice_data_type),           intent(inout) :: Ice !< The 	  type(ice_data_type),           intent(inout) :: Ice !< The 
  type(atmos_ice_boundary_type), intent(inout) :: Atmos_bound	  type(atmos_ice_boundary_type), intent(inout) :: Atmos_bound
                                                !! forcing fi	                                                !! forcing fi

  type(time_type) :: Time_start, Time_end, dT_fast		  type(time_type) :: Time_start, Time_end, dT_fast

  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c	  call cpu_clock_begin(iceClock) ; call cpu_clock_begin(ice_c

  if (Ice%fCS%debug) &						  if (Ice%fCS%debug) &
    call Ice_public_type_chksum("Pre do_update_ice_model_fast	    call Ice_public_type_chksum("Pre do_update_ice_model_fast

  dT_fast = Ice%fCS%Time_step_fast				  dT_fast = Ice%fCS%Time_step_fast
  Time_start = Ice%fCS%Time					  Time_start = Ice%fCS%Time
  Time_end = Time_start + dT_fast				  Time_end = Time_start + dT_fast

  if (Ice%fCS%Rad%add_diurnal_sw) &				  if (Ice%fCS%Rad%add_diurnal_sw) &
    call add_diurnal_sw(Atmos_boundary, Ice%fCS%G, Time_start	    call add_diurnal_sw(Atmos_boundary, Ice%fCS%G, Time_start

  call do_update_ice_model_fast(Atmos_boundary, Ice%fCS%IST, 	  call do_update_ice_model_fast(Atmos_boundary, Ice%fCS%IST, 
                                Ice%fCS%FIA, dT_fast, Ice%fCS	                                Ice%fCS%FIA, dT_fast, Ice%fCS
                                Ice%fCS%G, Ice%fCS%US, Ice%fC	                                Ice%fCS%G, Ice%fCS%US, Ice%fC

  ! Advance the master sea-ice time.				  ! Advance the master sea-ice time.
  Ice%fCS%Time = Ice%fCS%Time + dT_fast				  Ice%fCS%Time = Ice%fCS%Time + dT_fast

  Ice%Time = Ice%fCS%Time					  Ice%Time = Ice%fCS%Time

  call fast_radiation_diagnostics(Atmos_boundary, Ice, Ice%fC	  call fast_radiation_diagnostics(Atmos_boundary, Ice, Ice%fC
                                  Ice%fCS%G, Ice%fCS%US, Ice%	                                  Ice%fCS%G, Ice%fCS%US, Ice%

  ! Set some of the evolving ocean properties that will be se	  ! Set some of the evolving ocean properties that will be se
  ! atmosphere in the next time-step.				  ! atmosphere in the next time-step.
  call set_fast_ocean_sfc_properties(Atmos_boundary, Ice, Ice	  call set_fast_ocean_sfc_properties(Atmos_boundary, Ice, Ice
                                     Ice%fCS%G, Ice%fCS%US, I	                                     Ice%fCS%G, Ice%fCS%US, I

  if (Ice%fCS%debug) &						  if (Ice%fCS%debug) &
    call Ice_public_type_chksum("End do_update_ice_model_fast	    call Ice_public_type_chksum("End do_update_ice_model_fast
  if (Ice%fCS%bounds_check) &					  if (Ice%fCS%bounds_check) &
    call Ice_public_type_bounds_check(Ice, Ice%fCS%G, "End up	    call Ice_public_type_bounds_check(Ice, Ice%fCS%G, "End up

  call cpu_clock_end(ice_clock_fast) ; call cpu_clock_end(ice	  call cpu_clock_end(ice_clock_fast) ; call cpu_clock_end(ice

end subroutine update_ice_model_fast				end subroutine update_ice_model_fast

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> set_fast_ocean_sfc_properties updates the ocean surface pr	!> set_fast_ocean_sfc_properties updates the ocean surface pr
!! roughness and albedo for the rapidly evolving atmospheric 	!! roughness and albedo for the rapidly evolving atmospheric 
subroutine set_fast_ocean_sfc_properties( Atmos_boundary, Ice	subroutine set_fast_ocean_sfc_properties( Atmos_boundary, Ice
                                          G, US, IG, Time_sta	                                          G, US, IG, Time_sta
  type(atmos_ice_boundary_type), intent(in)    :: Atmos_bound	  type(atmos_ice_boundary_type), intent(in)    :: Atmos_bound
                                                      !! forc	                                                      !! forc
  type(ice_data_type),           intent(inout) :: Ice !< The 	  type(ice_data_type),           intent(inout) :: Ice !< The 
  type(ice_state_type),          intent(inout) :: IST !< A ty	  type(ice_state_type),          intent(inout) :: IST !< A ty
  type(ice_rad_type),            intent(inout) :: Rad !< A st	  type(ice_rad_type),            intent(inout) :: Rad !< A st
                                                      !! refl	                                                      !! refl
  type(fast_ice_avg_type),       intent(inout) :: FIA !< A ty	  type(fast_ice_avg_type),       intent(inout) :: FIA !< A ty
                                                      !! (mos	                                                      !! (mos
  type(SIS_hor_grid_type),       intent(inout) :: G   !< The 	  type(SIS_hor_grid_type),       intent(inout) :: G   !< The 
  type(unit_scale_type),         intent(in)    :: US  !< A st	  type(unit_scale_type),         intent(in)    :: US  !< A st
  type(ice_grid_type),           intent(inout) :: IG  !< The 	  type(ice_grid_type),           intent(inout) :: IG  !< The 
  type(time_type),               intent(in)    :: Time_start 	  type(time_type),               intent(in)    :: Time_start 
  type(time_type),               intent(in)    :: Time_end   	  type(time_type),               intent(in)    :: Time_end   

  real, parameter :: T_0degC = 273.15 ! 0 degrees C in Kelvin	  real, parameter :: T_0degC = 273.15 ! 0 degrees C in Kelvin
  logical :: coszen_changed					  logical :: coszen_changed
  integer :: i, j, k, i2, j2, k2, i3, j3, isc, iec, jsc, jec,	  integer :: i, j, k, i2, j2, k2, i3, j3, isc, iec, jsc, jec,
  integer :: io_A, jo_A, io_I, jo_I  ! Offsets for indexing c	  integer :: io_A, jo_A, io_I, jo_I  ! Offsets for indexing c

  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec ; nca	  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec ; nca
  io_A = LBOUND(Atmos_boundary%t_flux,1) - G%isc		  io_A = LBOUND(Atmos_boundary%t_flux,1) - G%isc
  jo_A = LBOUND(Atmos_boundary%t_flux,2) - G%jsc		  jo_A = LBOUND(Atmos_boundary%t_flux,2) - G%jsc
  io_I = LBOUND(Ice%t_surf,1) - G%isc				  io_I = LBOUND(Ice%t_surf,1) - G%isc
  jo_I = LBOUND(Ice%t_surf,2) - G%jsc				  jo_I = LBOUND(Ice%t_surf,2) - G%jsc

  call compute_ocean_roughness (Ice%ocean_pt, Atmos_boundary%	  call compute_ocean_roughness (Ice%ocean_pt, Atmos_boundary%
                                Ice%rough_heat(:,:,1), Ice%ro	                                Ice%rough_heat(:,:,1), Ice%ro

  ! Update publicly visible ice_data_type variables..		  ! Update publicly visible ice_data_type variables..
  coszen_changed = .false.					  coszen_changed = .false.
  !$OMP parallel do default(shared) private(i3,j3)		  !$OMP parallel do default(shared) private(i3,j3)
  do j=jsc,jec ; do i=isc,iec					  do j=jsc,jec ; do i=isc,iec
    i3 = i+io_A ; j3 = j+jo_A					    i3 = i+io_A ; j3 = j+jo_A
    Rad%coszen_nextrad(i,j) = Atmos_boundary%coszen(i3,j3,1)	    Rad%coszen_nextrad(i,j) = Atmos_boundary%coszen(i3,j3,1)
    FIA%p_atm_surf(i,j) = US%kg_m2s_to_RZ_T*US%m_s_to_L_T*Atm	    FIA%p_atm_surf(i,j) = US%kg_m2s_to_RZ_T*US%m_s_to_L_T*Atm
    if (Rad%coszen_nextrad(i,j) /= Rad%coszen_lastrad(i,j)) c	    if (Rad%coszen_nextrad(i,j) /= Rad%coszen_lastrad(i,j)) c
  enddo ; enddo							  enddo ; enddo

  !$OMP parallel do default(shared) private(i2,j2,k2)		  !$OMP parallel do default(shared) private(i2,j2,k2)
  do k=1,ncat ; do j=jsc,jec ; do i=isc,iec			  do k=1,ncat ; do j=jsc,jec ; do i=isc,iec
    i2 = i+io_I ; j2 = j+jo_I ; k2 = k+1			    i2 = i+io_I ; j2 = j+jo_I ; k2 = k+1
    Ice%t_surf(i2,j2,k2) = US%C_to_degC*Rad%t_skin(i,j,k) + T	    Ice%t_surf(i2,j2,k2) = US%C_to_degC*Rad%t_skin(i,j,k) + T
  enddo ; enddo ; enddo						  enddo ; enddo ; enddo

  ! set_ocean_albedo only needs to be called if do_sun_angle_	  ! set_ocean_albedo only needs to be called if do_sun_angle_
  ! if the coupled model's radiation timestep is shorter than	  ! if the coupled model's radiation timestep is shorter than
  ! timestep.  However, it is safe (if wasteful) to call it m	  ! timestep.  However, it is safe (if wasteful) to call it m
  if (Rad%do_sun_angle_for_alb) then				  if (Rad%do_sun_angle_for_alb) then
    call set_ocean_albedo_from_astronomy(Ice, G, Time_start, 	    call set_ocean_albedo_from_astronomy(Ice, G, Time_start, 
  elseif (coszen_changed) then					  elseif (coszen_changed) then
    call set_ocean_albedo_from_coszen(Ice, G, Rad%coszen_next	    call set_ocean_albedo_from_coszen(Ice, G, Rad%coszen_next
  endif								  endif

end subroutine set_fast_ocean_sfc_properties			end subroutine set_fast_ocean_sfc_properties

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> set_ocean_albedo uses the time and astronomical calculates	!> set_ocean_albedo uses the time and astronomical calculates
!! zenith angle and calculate the ocean albedo.			!! zenith angle and calculate the ocean albedo.
subroutine set_ocean_albedo_from_astronomy(Ice, G, Time_start	subroutine set_ocean_albedo_from_astronomy(Ice, G, Time_start
  type(ice_data_type),     intent(inout) :: Ice !< The public	  type(ice_data_type),     intent(inout) :: Ice !< The public
  type(SIS_hor_grid_type), intent(inout) :: G   !< The horizo	  type(SIS_hor_grid_type), intent(inout) :: G   !< The horizo
  type(time_type),         intent(in)    :: Time_start !< The	  type(time_type),         intent(in)    :: Time_start !< The
  type(time_type),         intent(in)    :: Time_end   !< The	  type(time_type),         intent(in)    :: Time_end   !< The

  real, dimension(G%isc:G%iec,G%jsc:G%jec) :: &			  real, dimension(G%isc:G%iec,G%jsc:G%jec) :: &
    dummy, &  ! A dummy array that is not used again.		    dummy, &  ! A dummy array that is not used again.
    cosz_alb  ! The cosine of the solar zenith angle for calc	    cosz_alb  ! The cosine of the solar zenith angle for calc
  real :: rad							  real :: rad
  real :: rrsun_dt_ice						  real :: rrsun_dt_ice
  type(time_type) :: dT_ice   ! The time interval for this up	  type(time_type) :: dT_ice   ! The time interval for this up
  integer :: i, j, isc, iec, jsc, jec				  integer :: i, j, isc, iec, jsc, jec

  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec		  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec

  rad = acos(-1.)/180.						  rad = acos(-1.)/180.
  dT_ice = Time_end - Time_start				  dT_ice = Time_end - Time_start

  call diurnal_solar(G%geoLatT(isc:iec,jsc:jec)*rad, G%geoLon	  call diurnal_solar(G%geoLatT(isc:iec,jsc:jec)*rad, G%geoLon
               Time_start, cosz=cosz_alb, fracday=dummy, rrsu	               Time_start, cosz=cosz_alb, fracday=dummy, rrsu
               dt_time=dT_ice)					               dt_time=dT_ice)

  call compute_ocean_albedo(Ice%ocean_pt, cosz_alb(:,:), Ice%	  call compute_ocean_albedo(Ice%ocean_pt, cosz_alb(:,:), Ice%
                            Ice%albedo_vis_dif(:,:,1), Ice%al	                            Ice%albedo_vis_dif(:,:,1), Ice%al
                            Ice%albedo_nir_dif(:,:,1), rad*G%	                            Ice%albedo_nir_dif(:,:,1), rad*G%
                            Ice%flux_u(:,:), Ice%flux_v(:,:) 	                            Ice%flux_u(:,:), Ice%flux_v(:,:) 

end subroutine set_ocean_albedo_from_astronomy			end subroutine set_ocean_albedo_from_astronomy

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> set_ocean_albedo uses either the input cosine of the solar	!> set_ocean_albedo uses either the input cosine of the solar
!! angle to calculate the ocean albedo.				!! angle to calculate the ocean albedo.
subroutine set_ocean_albedo_from_coszen(Ice, G, coszen)		subroutine set_ocean_albedo_from_coszen(Ice, G, coszen)
  type(ice_data_type),     intent(inout) :: Ice !< The public	  type(ice_data_type),     intent(inout) :: Ice !< The public
  type(SIS_hor_grid_type), intent(inout) :: G   !< The horizo	  type(SIS_hor_grid_type), intent(inout) :: G   !< The horizo
  real, dimension(G%isd:G%ied, G%jsd:G%jed), &			  real, dimension(G%isd:G%ied, G%jsd:G%jed), &
                           intent(in)    :: coszen !< Cosine 	                           intent(in)    :: coszen !< Cosine 

  real :: rad							  real :: rad
  integer :: i, j, isc, iec, jsc, jec				  integer :: i, j, isc, iec, jsc, jec

  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec		  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec

  rad = acos(-1.)/180.						  rad = acos(-1.)/180.

  call compute_ocean_albedo(Ice%ocean_pt, coszen(isc:iec,jsc:	  call compute_ocean_albedo(Ice%ocean_pt, coszen(isc:iec,jsc:
                            Ice%albedo_vis_dif(:,:,1), Ice%al	                            Ice%albedo_vis_dif(:,:,1), Ice%al
                            Ice%albedo_nir_dif(:,:,1), rad*G%	                            Ice%albedo_nir_dif(:,:,1), rad*G%

end subroutine set_ocean_albedo_from_coszen			end subroutine set_ocean_albedo_from_coszen

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> fast_radiation_diagnostics offers diagnostics of the rapid	!> fast_radiation_diagnostics offers diagnostics of the rapid
!! radiative and other properties of the ice, and it accumula	!! radiative and other properties of the ice, and it accumula
subroutine fast_radiation_diagnostics(ABT, Ice, IST, Rad, FIA	subroutine fast_radiation_diagnostics(ABT, Ice, IST, Rad, FIA
                                      Time_start, Time_end)	                                      Time_start, Time_end)
  type(atmos_ice_boundary_type), &				  type(atmos_ice_boundary_type), &
                           intent(in)    :: ABT !< A type con	                           intent(in)    :: ABT !< A type con
                                                !! forcing fi	                                                !! forcing fi
  type(ice_data_type),     intent(in)    :: Ice !< The public	  type(ice_data_type),     intent(in)    :: Ice !< The public
  type(ice_state_type),    intent(in)    :: IST !< A type des	  type(ice_state_type),    intent(in)    :: IST !< A type des
  type(ice_rad_type),      intent(in)    :: Rad !< A structur	  type(ice_rad_type),      intent(in)    :: Rad !< A structur
                                                !! reflection	                                                !! reflection
  type(fast_ice_avg_type), intent(inout) :: FIA !< A type con	  type(fast_ice_avg_type), intent(inout) :: FIA !< A type con
                                                !! (mostly fl	                                                !! (mostly fl
  type(SIS_hor_grid_type), intent(in)    :: G   !< The horizo	  type(SIS_hor_grid_type), intent(in)    :: G   !< The horizo
  type(unit_scale_type),   intent(in)    :: US  !< A structur	  type(unit_scale_type),   intent(in)    :: US  !< A structur
  type(ice_grid_type),     intent(in)    :: IG  !< The sea-ic	  type(ice_grid_type),     intent(in)    :: IG  !< The sea-ic
  type(SIS_fast_CS),       intent(inout) :: CS  !< The fast i	  type(SIS_fast_CS),       intent(inout) :: CS  !< The fast i
  type(time_type),         intent(in)    :: Time_start !< The	  type(time_type),         intent(in)    :: Time_start !< The
  type(time_type),         intent(in)    :: Time_end   !< The	  type(time_type),         intent(in)    :: Time_end   !< The

  real, dimension(G%isd:G%ied, G%jsd:G%jed) :: tmp_diag, sw_d	  real, dimension(G%isd:G%ied, G%jsd:G%jed) :: tmp_diag, sw_d
  real, dimension(G%isd:G%ied, G%jsd:G%jed,size(FIA%flux_sw_d	  real, dimension(G%isd:G%ied, G%jsd:G%jed,size(FIA%flux_sw_d
    sw_dn_bnd  ! The downward shortwave radiation by frequenc	    sw_dn_bnd  ! The downward shortwave radiation by frequenc
               ! averaged over all of the ice thickness categ	               ! averaged over all of the ice thickness categ
  real, dimension(G%isd:G%ied) :: Tskin_avg ! Average skin te	  real, dimension(G%isd:G%ied) :: Tskin_avg ! Average skin te
  real, dimension(G%isd:G%ied) :: ice_conc			  real, dimension(G%isd:G%ied) :: ice_conc
  real :: dt_diag						  real :: dt_diag
  real    :: Stefan ! The Stefan-Boltzmann constant [W m-2 de	  real    :: Stefan ! The Stefan-Boltzmann constant [W m-2 de
                    ! strictly diagnostic purposes.		                    ! strictly diagnostic purposes.
  real, parameter :: T_0degC = 273.15 ! 0 degrees C in Kelvin	  real, parameter :: T_0degC = 273.15 ! 0 degrees C in Kelvin
  integer :: i, j, k, m, i2, j2, k2, i3, j3, isc, iec, jsc, j	  integer :: i, j, k, m, i2, j2, k2, i3, j3, isc, iec, jsc, j
  integer :: b							  integer :: b
  integer :: io_A, jo_A, io_I, jo_I  ! Offsets for indexing c	  integer :: io_A, jo_A, io_I, jo_I  ! Offsets for indexing c

  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec ; nca	  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec ; nca
  NkIce = IG%NkIce						  NkIce = IG%NkIce
  io_A = LBOUND(ABT%lw_flux,1) - G%isc ; jo_A = LBOUND(ABT%lw	  io_A = LBOUND(ABT%lw_flux,1) - G%isc ; jo_A = LBOUND(ABT%lw
  io_I = LBOUND(Ice%albedo_vis_dir,1) - G%isc			  io_I = LBOUND(Ice%albedo_vis_dir,1) - G%isc
  jo_I = LBOUND(Ice%albedo_vis_dir,2) - G%jsc			  jo_I = LBOUND(Ice%albedo_vis_dir,2) - G%jsc

  dt_diag = time_type_to_real(Time_end - Time_start)		  dt_diag = time_type_to_real(Time_end - Time_start)

  call enable_SIS_averaging(dt_diag, Time_end, CS%diag)		  call enable_SIS_averaging(dt_diag, Time_end, CS%diag)

  if (Rad%id_alb_vis_dir>0) call post_avg(Rad%id_alb_vis_dir,	  if (Rad%id_alb_vis_dir>0) call post_avg(Rad%id_alb_vis_dir,
                              IST%part_size(isc:iec,jsc:jec,:	                              IST%part_size(isc:iec,jsc:jec,:
  if (Rad%id_alb_vis_dif>0) call post_avg(Rad%id_alb_vis_dif,	  if (Rad%id_alb_vis_dif>0) call post_avg(Rad%id_alb_vis_dif,
                              IST%part_size(isc:iec,jsc:jec,:	                              IST%part_size(isc:iec,jsc:jec,:
  if (Rad%id_alb_nir_dir>0) call post_avg(Rad%id_alb_nir_dir,	  if (Rad%id_alb_nir_dir>0) call post_avg(Rad%id_alb_nir_dir,
                              IST%part_size(isc:iec,jsc:jec,:	                              IST%part_size(isc:iec,jsc:jec,:
  if (Rad%id_alb_nir_dif>0) call post_avg(Rad%id_alb_nir_dif,	  if (Rad%id_alb_nir_dif>0) call post_avg(Rad%id_alb_nir_dif,
                              IST%part_size(isc:iec,jsc:jec,:	                              IST%part_size(isc:iec,jsc:jec,:
  if (Rad%id_alb>0)         call post_avg(Rad%id_alb, Ice%alb	  if (Rad%id_alb>0)         call post_avg(Rad%id_alb, Ice%alb
                              IST%part_size(isc:iec,jsc:jec,:	                              IST%part_size(isc:iec,jsc:jec,:

  if (Rad%id_tskin>0) call post_data(Rad%id_tskin, Rad%t_skin	  if (Rad%id_tskin>0) call post_data(Rad%id_tskin, Rad%t_skin
  if (Rad%id_cn>0) call post_data(Rad%id_cn, IST%part_size(:,	  if (Rad%id_cn>0) call post_data(Rad%id_cn, IST%part_size(:,
  if (Rad%id_mi>0) call post_data(Rad%id_mi, IST%mH_ice(:,:,:	  if (Rad%id_mi>0) call post_data(Rad%id_mi, IST%mH_ice(:,:,:

  if (Rad%id_sw_abs_sfc>0) call post_avg(Rad%id_sw_abs_sfc, R	  if (Rad%id_sw_abs_sfc>0) call post_avg(Rad%id_sw_abs_sfc, R
                                   IST%part_size(:,:,1:), CS%	                                   IST%part_size(:,:,1:), CS%
  if (Rad%id_sw_abs_snow>0) call post_avg(Rad%id_sw_abs_snow,	  if (Rad%id_sw_abs_snow>0) call post_avg(Rad%id_sw_abs_snow,
                                   IST%part_size(:,:,1:), CS%	                                   IST%part_size(:,:,1:), CS%
  if (allocated(Rad%id_sw_abs_ice)) then ; do m=1,NkIce		  if (allocated(Rad%id_sw_abs_ice)) then ; do m=1,NkIce
    if (Rad%id_sw_abs_ice(m)>0) call post_avg(Rad%id_sw_abs_i	    if (Rad%id_sw_abs_ice(m)>0) call post_avg(Rad%id_sw_abs_i
                                     IST%part_size(:,:,1:), C	                                     IST%part_size(:,:,1:), C
  enddo ; endif							  enddo ; endif
  if (Rad%id_sw_abs_ocn>0) call post_avg(Rad%id_sw_abs_ocn, R	  if (Rad%id_sw_abs_ocn>0) call post_avg(Rad%id_sw_abs_ocn, R
                                   IST%part_size(:,:,1:), CS%	                                   IST%part_size(:,:,1:), CS%

  if (Rad%id_sw_pen>0) then					  if (Rad%id_sw_pen>0) then
    tmp_diag(:,:) = 0.0						    tmp_diag(:,:) = 0.0
    !$OMP parallel do default(shared)				    !$OMP parallel do default(shared)
    do j=jsc,jec ; do k=1,ncat ; do i=isc,iec			    do j=jsc,jec ; do k=1,ncat ; do i=isc,iec
      tmp_diag(i,j) = tmp_diag(i,j) + IST%part_size(i,j,k) * 	      tmp_diag(i,j) = tmp_diag(i,j) + IST%part_size(i,j,k) * 
                     (Rad%sw_abs_ocn(i,j,k) + Rad%sw_abs_int(	                     (Rad%sw_abs_ocn(i,j,k) + Rad%sw_abs_int(
    enddo ; enddo ; enddo					    enddo ; enddo ; enddo
    call post_data(Rad%id_sw_pen, tmp_diag, CS%diag)		    call post_data(Rad%id_sw_pen, tmp_diag, CS%diag)
  endif								  endif

  if (Rad%id_lwdn > 0) then					  if (Rad%id_lwdn > 0) then
    tmp_diag(:,:) = 0.0						    tmp_diag(:,:) = 0.0
    Stefan = 5.6734e-8  ! Set the Stefan-Bolzmann constant [W	    Stefan = 5.6734e-8  ! Set the Stefan-Bolzmann constant [W
    do k=0,ncat ; do j=jsc,jec ; do i=isc,iec ; if (G%mask2dT	    do k=0,ncat ; do j=jsc,jec ; do i=isc,iec ; if (G%mask2dT
      i3 = i+io_A ; j3 = j+jo_A ; k2 = k+1			      i3 = i+io_A ; j3 = j+jo_A ; k2 = k+1
      tmp_diag(i,j) = tmp_diag(i,j) + IST%part_size(i,j,k) * 	      tmp_diag(i,j) = tmp_diag(i,j) + IST%part_size(i,j,k) * 
                           (ABT%lw_flux(i3,j3,k2) + Stefan*(U	                           (ABT%lw_flux(i3,j3,k2) + Stefan*(U
    endif ; enddo ; enddo ; enddo				    endif ; enddo ; enddo ; enddo
    call post_data(Rad%id_lwdn, tmp_diag, CS%diag)		    call post_data(Rad%id_lwdn, tmp_diag, CS%diag)
  endif								  endif

  sw_dn(:,:) = 0.0 ; net_sw(:,:) = 0.0 ; avg_alb(:,:) = 0.0 ;	  sw_dn(:,:) = 0.0 ; net_sw(:,:) = 0.0 ; avg_alb(:,:) = 0.0 ;
  !$OMP parallel do default(shared) private(i2,j2,k2,i3,j3)	  !$OMP parallel do default(shared) private(i2,j2,k2,i3,j3)
  do j=jsc,jec ; do k=0,ncat ; do i=isc,iec ; if (G%mask2dT(i	  do j=jsc,jec ; do k=0,ncat ; do i=isc,iec ; if (G%mask2dT(i
    i2 = i+io_I ; j2 = j+jo_I ; i3 = i+io_A ; j3 = j+jo_A ; k	    i2 = i+io_I ; j2 = j+jo_I ; i3 = i+io_A ; j3 = j+jo_A ; k
    if (associated(ABT%sw_down_vis_dir)) then			    if (associated(ABT%sw_down_vis_dir)) then
      sw_dn(i,j) = sw_dn(i,j) + IST%part_size(i,j,k) * ( &	      sw_dn(i,j) = sw_dn(i,j) + IST%part_size(i,j,k) * ( &
            (ABT%sw_down_vis_dir(i3,j3,k2) + ABT%sw_down_vis_	            (ABT%sw_down_vis_dir(i3,j3,k2) + ABT%sw_down_vis_
            (ABT%sw_down_nir_dir(i3,j3,k2) + ABT%sw_down_nir_	            (ABT%sw_down_nir_dir(i3,j3,k2) + ABT%sw_down_nir_
      sw_dn_bnd(i,j,VIS_DIR) = sw_dn_bnd(i,j,VIS_DIR) + &	      sw_dn_bnd(i,j,VIS_DIR) = sw_dn_bnd(i,j,VIS_DIR) + &
                     IST%part_size(i,j,k) * ABT%sw_down_vis_d	                     IST%part_size(i,j,k) * ABT%sw_down_vis_d
      sw_dn_bnd(i,j,VIS_DIF) = sw_dn_bnd(i,j,VIS_DIF) + &	      sw_dn_bnd(i,j,VIS_DIF) = sw_dn_bnd(i,j,VIS_DIF) + &
                     IST%part_size(i,j,k) * ABT%sw_down_vis_d	                     IST%part_size(i,j,k) * ABT%sw_down_vis_d
      sw_dn_bnd(i,j,NIR_DIR) = sw_dn_bnd(i,j,NIR_DIR) + &	      sw_dn_bnd(i,j,NIR_DIR) = sw_dn_bnd(i,j,NIR_DIR) + &
                     IST%part_size(i,j,k) * ABT%sw_down_nir_d	                     IST%part_size(i,j,k) * ABT%sw_down_nir_d
      sw_dn_bnd(i,j,NIR_DIF) = sw_dn_bnd(i,j,NIR_DIF) + &	      sw_dn_bnd(i,j,NIR_DIF) = sw_dn_bnd(i,j,NIR_DIF) + &
                     IST%part_size(i,j,k) * ABT%sw_down_nir_d	                     IST%part_size(i,j,k) * ABT%sw_down_nir_d
    else							    else
      sw_dn(i,j) = sw_dn(i,j) + IST%part_size(i,j,k) * ( &	      sw_dn(i,j) = sw_dn(i,j) + IST%part_size(i,j,k) * ( &
            (ABT%sw_flux_vis_dir(i3,j3,k2)/(1-Ice%albedo_vis_	            (ABT%sw_flux_vis_dir(i3,j3,k2)/(1-Ice%albedo_vis_
             ABT%sw_flux_vis_dif(i3,j3,k2)/(1-Ice%albedo_vis_	             ABT%sw_flux_vis_dif(i3,j3,k2)/(1-Ice%albedo_vis_
            (ABT%sw_flux_nir_dir(i3,j3,k2)/(1-Ice%albedo_nir_	            (ABT%sw_flux_nir_dir(i3,j3,k2)/(1-Ice%albedo_nir_
             ABT%sw_flux_nir_dif(i3,j3,k2)/(1-Ice%albedo_nir_	             ABT%sw_flux_nir_dif(i3,j3,k2)/(1-Ice%albedo_nir_
      sw_dn_bnd(i,j,VIS_DIR) = sw_dn_bnd(i,j,VIS_DIR) + IST%p	      sw_dn_bnd(i,j,VIS_DIR) = sw_dn_bnd(i,j,VIS_DIR) + IST%p
            (ABT%sw_flux_vis_dir(i3,j3,k2)/(1.0-Ice%albedo_vi	            (ABT%sw_flux_vis_dir(i3,j3,k2)/(1.0-Ice%albedo_vi
      sw_dn_bnd(i,j,VIS_DIF) = sw_dn_bnd(i,j,VIS_DIF) + IST%p	      sw_dn_bnd(i,j,VIS_DIF) = sw_dn_bnd(i,j,VIS_DIF) + IST%p
            (ABT%sw_flux_vis_dif(i3,j3,k2)/(1.0-Ice%albedo_vi	            (ABT%sw_flux_vis_dif(i3,j3,k2)/(1.0-Ice%albedo_vi
      sw_dn_bnd(i,j,NIR_DIR) = sw_dn_bnd(i,j,NIR_DIR) + IST%p	      sw_dn_bnd(i,j,NIR_DIR) = sw_dn_bnd(i,j,NIR_DIR) + IST%p
            (ABT%sw_flux_nir_dir(i3,j3,k2)/(1.0-Ice%albedo_ni	            (ABT%sw_flux_nir_dir(i3,j3,k2)/(1.0-Ice%albedo_ni
      sw_dn_bnd(i,j,NIR_DIF) = sw_dn_bnd(i,j,NIR_DIF) + IST%p	      sw_dn_bnd(i,j,NIR_DIF) = sw_dn_bnd(i,j,NIR_DIF) + IST%p
            (ABT%sw_flux_nir_dif(i3,j3,k2)/(1.0-Ice%albedo_ni	            (ABT%sw_flux_nir_dif(i3,j3,k2)/(1.0-Ice%albedo_ni
    endif							    endif

    net_sw(i,j) = net_sw(i,j) + IST%part_size(i,j,k) * ( &	    net_sw(i,j) = net_sw(i,j) + IST%part_size(i,j,k) * ( &
          (ABT%sw_flux_vis_dir(i3,j3,k2) + ABT%sw_flux_vis_di	          (ABT%sw_flux_vis_dir(i3,j3,k2) + ABT%sw_flux_vis_di
          (ABT%sw_flux_nir_dir(i3,j3,k2) + ABT%sw_flux_nir_di	          (ABT%sw_flux_nir_dir(i3,j3,k2) + ABT%sw_flux_nir_di
    avg_alb(i,j) = avg_alb(i,j) + IST%part_size(i,j,k) * 0.25	    avg_alb(i,j) = avg_alb(i,j) + IST%part_size(i,j,k) * 0.25
            (Ice%albedo_vis_dir(i2,j2,k2) + Ice%albedo_vis_di	            (Ice%albedo_vis_dir(i2,j2,k2) + Ice%albedo_vis_di
            (Ice%albedo_nir_dir(i2,j2,k2) + Ice%albedo_nir_di	            (Ice%albedo_nir_dir(i2,j2,k2) + Ice%albedo_nir_di
    ! Consider recalculating this as avg_alb(i,j) = 1.0 - net	    ! Consider recalculating this as avg_alb(i,j) = 1.0 - net
  endif ; enddo ; enddo ; enddo					  endif ; enddo ; enddo ; enddo

  !$OMP parallel do default(shared) private(Tskin_avg,ice_con	  !$OMP parallel do default(shared) private(Tskin_avg,ice_con
  do j=jsc,jec							  do j=jsc,jec
    Tskin_avg(:) = 0.0 ; ice_conc(:) = 0.0			    Tskin_avg(:) = 0.0 ; ice_conc(:) = 0.0
    do k=1,ncat ; do i=isc,iec					    do k=1,ncat ; do i=isc,iec
      Tskin_avg(i) = Tskin_avg(i) + Rad%t_skin(i,j,k) * IST%p	      Tskin_avg(i) = Tskin_avg(i) + Rad%t_skin(i,j,k) * IST%p
      ice_conc(i) = ice_conc(i) + IST%part_size(i,j,k)		      ice_conc(i) = ice_conc(i) + IST%part_size(i,j,k)
    enddo ; enddo						    enddo ; enddo
    do i=isc,iec						    do i=isc,iec
      if (ice_conc(i)>0.0) then					      if (ice_conc(i)>0.0) then
        FIA%Tskin_avg(i,j) = FIA%Tskin_avg(i,j) + (Tskin_avg(	        FIA%Tskin_avg(i,j) = FIA%Tskin_avg(i,j) + (Tskin_avg(
      ! else there is nothing to add, because Tskin_avg = 0.	      ! else there is nothing to add, because Tskin_avg = 0.
      endif							      endif
    enddo							    enddo
  enddo								  enddo

  if (Rad%id_swdn > 0) call post_data(Rad%id_swdn, sw_dn, CS%	  if (Rad%id_swdn > 0) call post_data(Rad%id_swdn, sw_dn, CS%

  if (Rad%id_alb > 0) then					  if (Rad%id_alb > 0) then
    do j=jsc,jec ; do i=isc,iec ; if (G%mask2dT(i,j)>0.0) the	    do j=jsc,jec ; do i=isc,iec ; if (G%mask2dT(i,j)>0.0) the
      if (sw_dn(i,j) > 0.0) &					      if (sw_dn(i,j) > 0.0) &
        avg_alb(i,j) = (sw_dn(i,j) - net_sw(i,j)) / sw_dn(i,j	        avg_alb(i,j) = (sw_dn(i,j) - net_sw(i,j)) / sw_dn(i,j
      ! Otherwise keep the simple average that was set above.	      ! Otherwise keep the simple average that was set above.
    endif ; enddo ; enddo					    endif ; enddo ; enddo
    call post_data(Rad%id_alb, avg_alb, CS%diag)		    call post_data(Rad%id_alb, avg_alb, CS%diag)
  endif								  endif

  do j=jsc,jec ; do i=isc,iec ; if (G%mask2dT(i,j)>0.0) then	  do j=jsc,jec ; do i=isc,iec ; if (G%mask2dT(i,j)>0.0) then
    do b=1,size(FIA%flux_sw_dn,3)				    do b=1,size(FIA%flux_sw_dn,3)
      FIA%flux_sw_dn(i,j,b) = FIA%flux_sw_dn(i,j,b) + US%W_m2	      FIA%flux_sw_dn(i,j,b) = FIA%flux_sw_dn(i,j,b) + US%W_m2
    enddo							    enddo
  endif ; enddo ; enddo						  endif ; enddo ; enddo

  if (Rad%id_coszen>0) call post_data(Rad%id_coszen, Rad%cosz	  if (Rad%id_coszen>0) call post_data(Rad%id_coszen, Rad%cosz

  call disable_SIS_averaging(CS%diag)				  call disable_SIS_averaging(CS%diag)

end subroutine fast_radiation_diagnostics			end subroutine fast_radiation_diagnostics

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> add_diurnal_SW adjusts the shortwave fluxes in an atmos_bo	!> add_diurnal_SW adjusts the shortwave fluxes in an atmos_bo
!! to add a synthetic diurnal cycle.				!! to add a synthetic diurnal cycle.
subroutine add_diurnal_SW(ABT, G, Time_start, Time_end)		subroutine add_diurnal_SW(ABT, G, Time_start, Time_end)
  type(atmos_ice_boundary_type), intent(inout) :: ABT !< The 	  type(atmos_ice_boundary_type), intent(inout) :: ABT !< The 
  type(SIS_hor_grid_type),       intent(in)    :: G   !< The 	  type(SIS_hor_grid_type),       intent(in)    :: G   !< The 
  type(time_type),               intent(in)    :: Time_start 	  type(time_type),               intent(in)    :: Time_start 
  type(time_type),               intent(in)    :: Time_end   	  type(time_type),               intent(in)    :: Time_end   

  real :: diurnal_factor, time_since_ae, rad			  real :: diurnal_factor, time_since_ae, rad
  real :: fracday_dt, fracday_day				  real :: fracday_dt, fracday_day
  real :: cosz_day, cosz_dt, rrsun_day, rrsun_dt		  real :: cosz_day, cosz_dt, rrsun_day, rrsun_dt
  type(time_type) :: dt_here					  type(time_type) :: dt_here

  integer :: i, j, k, i2, j2, isc, iec, jsc, jec, ncat, i_off	  integer :: i, j, k, i2, j2, isc, iec, jsc, jec, ncat, i_off

  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec		  isc = G%isc ; iec = G%iec ; jsc = G%jsc ; jec = G%jec
  ncat = size(ABT%sw_flux_nir_dir,3)				  ncat = size(ABT%sw_flux_nir_dir,3)
  i_off = LBOUND(ABT%t_flux,1) - G%isc ; j_off = LBOUND(ABT%t	  i_off = LBOUND(ABT%t_flux,1) - G%isc ; j_off = LBOUND(ABT%t

  !   Orbital_time extracts the time of year relative to the 	  !   Orbital_time extracts the time of year relative to the 
  ! hemisphere autumnal equinox from a time_type variable.	  ! hemisphere autumnal equinox from a time_type variable.
  time_since_ae = orbital_time(Time_start)			  time_since_ae = orbital_time(Time_start)
  dt_here = Time_end - Time_start				  dt_here = Time_end - Time_start
  rad = acos(-1.)/180.						  rad = acos(-1.)/180.

!$OMP parallel do default(none) shared(isc,iec,jsc,jec,G,rad,	!$OMP parallel do default(none) shared(isc,iec,jsc,jec,G,rad,
!$OMP                                  ncat,ABT,i_off,j_off) 	!$OMP                                  ncat,ABT,i_off,j_off) 
!$OMP                          private(i,j,i2,j2,k,cosz_dt,fr	!$OMP                          private(i,j,i2,j2,k,cosz_dt,fr
!$OMP                                  fracday_day,cosz_day,r	!$OMP                                  fracday_day,cosz_day,r
  do j=jsc,jec ; do i=isc,iec					  do j=jsc,jec ; do i=isc,iec
!    Per Rick Hemler:						!    Per Rick Hemler:
!      Call diurnal_solar with dtime=dt_here to get cosz aver	!      Call diurnal_solar with dtime=dt_here to get cosz aver
!      Call daily_mean_solar to get cosz averaged over a day.	!      Call daily_mean_solar to get cosz averaged over a day.
!      diurnal_factor = cosz_dt_ice*fracday_dt_ice*rrsun_dt_i	!      diurnal_factor = cosz_dt_ice*fracday_dt_ice*rrsun_dt_i
!                       cosz_day*fracday_day*rrsun_day		!                       cosz_day*fracday_day*rrsun_day

    call diurnal_solar(G%geoLatT(i,j)*rad, G%geoLonT(i,j)*rad	    call diurnal_solar(G%geoLatT(i,j)*rad, G%geoLonT(i,j)*rad
                       fracday=fracday_dt, rrsun=rrsun_dt, dt	                       fracday=fracday_dt, rrsun=rrsun_dt, dt
    call daily_mean_solar (G%geoLatT(i,j)*rad, time_since_ae,	    call daily_mean_solar (G%geoLatT(i,j)*rad, time_since_ae,
    diurnal_factor = cosz_dt*fracday_dt*rrsun_dt / &		    diurnal_factor = cosz_dt*fracday_dt*rrsun_dt / &
                     max(1e-30, cosz_day*fracday_day*rrsun_da	                     max(1e-30, cosz_day*fracday_day*rrsun_da

    i2 = i+i_off ; j2 = j+j_off					    i2 = i+i_off ; j2 = j+j_off
    do k=1,ncat							    do k=1,ncat
      ABT%sw_flux_nir_dir(i2,j2,k) = ABT%sw_flux_nir_dir(i2,j	      ABT%sw_flux_nir_dir(i2,j2,k) = ABT%sw_flux_nir_dir(i2,j
      ABT%sw_flux_nir_dif(i2,j2,k) = ABT%sw_flux_nir_dif(i2,j	      ABT%sw_flux_nir_dif(i2,j2,k) = ABT%sw_flux_nir_dif(i2,j
      ABT%sw_flux_vis_dir(i2,j2,k) = ABT%sw_flux_vis_dir(i2,j	      ABT%sw_flux_vis_dir(i2,j2,k) = ABT%sw_flux_vis_dir(i2,j
      ABT%sw_flux_vis_dif(i2,j2,k) = ABT%sw_flux_vis_dif(i2,j	      ABT%sw_flux_vis_dif(i2,j2,k) = ABT%sw_flux_vis_dif(i2,j
    enddo							    enddo
    if (associated(ABT%sw_down_nir_dir)) then ; do k=1,ncat	    if (associated(ABT%sw_down_nir_dir)) then ; do k=1,ncat
      ABT%sw_down_nir_dir(i2,j2,k) = ABT%sw_down_nir_dir(i2,j	      ABT%sw_down_nir_dir(i2,j2,k) = ABT%sw_down_nir_dir(i2,j
    enddo ; endif						    enddo ; endif
    if (associated(ABT%sw_down_nir_dif)) then ; do k=1,ncat	    if (associated(ABT%sw_down_nir_dif)) then ; do k=1,ncat
      ABT%sw_down_nir_dif(i2,j2,k) = ABT%sw_down_nir_dif(i2,j	      ABT%sw_down_nir_dif(i2,j2,k) = ABT%sw_down_nir_dif(i2,j
    enddo ; endif						    enddo ; endif
    if (associated(ABT%sw_down_vis_dir)) then ; do k=1,ncat	    if (associated(ABT%sw_down_vis_dir)) then ; do k=1,ncat
      ABT%sw_down_vis_dir(i2,j2,k) = ABT%sw_down_vis_dir(i2,j	      ABT%sw_down_vis_dir(i2,j2,k) = ABT%sw_down_vis_dir(i2,j
    enddo ; endif						    enddo ; endif
    if (associated(ABT%sw_down_vis_dif)) then ; do k=1,ncat	    if (associated(ABT%sw_down_vis_dif)) then ; do k=1,ncat
      ABT%sw_down_vis_dif(i2,j2,k) = ABT%sw_down_vis_dif(i2,j	      ABT%sw_down_vis_dif(i2,j2,k) = ABT%sw_down_vis_dif(i2,j
    enddo ; endif						    enddo ; endif
  enddo ; enddo							  enddo ; enddo

end subroutine add_diurnal_sw					end subroutine add_diurnal_sw

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> ice_model_init - initializes ice model data, parameters an	!> ice_model_init - initializes ice model data, parameters an
!! might operate on the fast ice processors, the slow ice pro	!! might operate on the fast ice processors, the slow ice pro
subroutine ice_model_init(Ice, Time_Init, Time, Time_step_fas	subroutine ice_model_init(Ice, Time_Init, Time, Time_step_fas
                          Verona_coupler, Concurrent_atm, Con	                          Verona_coupler, Concurrent_atm, Con

  type(ice_data_type), intent(inout) :: Ice            !< The	  type(ice_data_type), intent(inout) :: Ice            !< The
  type(time_type)    , intent(in)    :: Time_Init      !< The	  type(time_type)    , intent(in)    :: Time_Init      !< The
  type(time_type)    , intent(in)    :: Time           !< The	  type(time_type)    , intent(in)    :: Time           !< The
  type(time_type)    , intent(in)    :: Time_step_fast !< The	  type(time_type)    , intent(in)    :: Time_step_fast !< The
  type(time_type)    , intent(in)    :: Time_step_slow !< The	  type(time_type)    , intent(in)    :: Time_step_slow !< The
  logical,   optional, intent(in)    :: Verona_coupler !< If 	  logical,   optional, intent(in)    :: Verona_coupler !< If 
                                              !! in Ice to de	                                              !! in Ice to de
                                              !! ice processo	                                              !! ice processo
                                              !! error if thi	                                              !! error if thi
  logical,   optional, intent(in)    :: Concurrent_atm		  logical,   optional, intent(in)    :: Concurrent_atm
  logical,   optional, intent(in)    :: Concurrent_ice !< If 	  logical,   optional, intent(in)    :: Concurrent_ice !< If 
                                              !! settings app	                                              !! settings app
                                              !! slow ice sim	                                              !! slow ice sim
                                              !! slow sea-ice	                                              !! slow sea-ice
  type(coupler_1d_bc_type), &					  type(coupler_1d_bc_type), &
             optional, intent(in)     :: gas_fluxes !< If pre	             optional, intent(in)     :: gas_fluxes !< If pre
                                              !! additional g	                                              !! additional g
                                              !! ocean, ice, 	                                              !! ocean, ice, 
                                              !! spawn relate	                                              !! spawn relate
  type(coupler_1d_bc_type), &					  type(coupler_1d_bc_type), &
             optional, intent(in)     :: gas_fields_ocn !< If	             optional, intent(in)     :: gas_fields_ocn !< If
                                              !! ocean and su	                                              !! ocean and su
                                              !! in the calcu	                                              !! in the calcu
                                              !! tracer fluxe	                                              !! tracer fluxe
                                              !! internal var	                                              !! internal var

  ! This include declares and sets the variable "version".	  ! This include declares and sets the variable "version".
# include "version_variable.h"					# include "version_variable.h"
  real :: enth_spec_snow, enth_spec_ice				  real :: enth_spec_snow, enth_spec_ice
  real :: pi ! pi = 3.1415926... calculated as 4*atan(1)	  real :: pi ! pi = 3.1415926... calculated as 4*atan(1)
  integer :: i, j, k, l, i2, j2, k2, i_off, j_off, n		  integer :: i, j, k, l, i2, j2, k2, i_off, j_off, n
  integer :: isc, iec, jsc, jec, nCat_dflt			  integer :: isc, iec, jsc, jec, nCat_dflt
  character(len=120) :: restart_file, fast_rest_file		  character(len=120) :: restart_file, fast_rest_file
  character(len=40)  :: mdl = "ice_model" ! This module's nam	  character(len=40)  :: mdl = "ice_model" ! This module's nam
  character(len=8)   :: nstr					  character(len=8)   :: nstr
  type(directories)  :: dirs   ! A structure containing sever	  type(directories)  :: dirs   ! A structure containing sever

  type(param_file_type) :: param_file !< A structure to parse	  type(param_file_type) :: param_file !< A structure to parse
  type(hor_index_type)  :: fHI  !  A hor_index_type for array	  type(hor_index_type)  :: fHI  !  A hor_index_type for array
  type(hor_index_type)  :: sHI  !  A hor_index_type for array	  type(hor_index_type)  :: sHI  !  A hor_index_type for array

  type(dyn_horgrid_type),  pointer :: dG => NULL()		  type(dyn_horgrid_type),  pointer :: dG => NULL()
  type(unit_scale_type),   pointer :: US => NULL()		  type(unit_scale_type),   pointer :: US => NULL()
  ! These pointers are used only for coding convenience on sl	  ! These pointers are used only for coding convenience on sl
  type(SIS_hor_grid_type), pointer :: sG => NULL()		  type(SIS_hor_grid_type), pointer :: sG => NULL()
  type(MOM_domain_type),   pointer :: sGD => NULL()		  type(MOM_domain_type),   pointer :: sGD => NULL()
  type(ice_state_type),    pointer :: sIST => NULL()		  type(ice_state_type),    pointer :: sIST => NULL()
  type(ice_grid_type),     pointer :: sIG => NULL()		  type(ice_grid_type),     pointer :: sIG => NULL()

  ! These pointers are used only for coding convenience on fa	  ! These pointers are used only for coding convenience on fa
  type(SIS_hor_grid_type), pointer :: fG => NULL()		  type(SIS_hor_grid_type), pointer :: fG => NULL()
  type(MOM_domain_type), pointer :: fGD => NULL()		  type(MOM_domain_type), pointer :: fGD => NULL()

  ! Parameters that are read in and used to initialize other 	  ! Parameters that are read in and used to initialize other 
  ! other modules had control states, these would be moved to	  ! other modules had control states, these would be moved to
  real :: mom_rough_ice  ! momentum same, cd10=(von_k/ln(10/z	  real :: mom_rough_ice  ! momentum same, cd10=(von_k/ln(10/z
  real :: heat_rough_ice ! heat roughness length [m].		  real :: heat_rough_ice ! heat roughness length [m].
  real :: dt_Rad_real    ! The radiation timestep [s].		  real :: dt_Rad_real    ! The radiation timestep [s].
  type(time_type) :: dt_Rad ! The radiation timestep, used in	  type(time_type) :: dt_Rad ! The radiation timestep, used in
  real :: rad            ! The conversion factor from degrees	  real :: rad            ! The conversion factor from degrees
  real :: rrsun          ! An unused temporary factor related	  real :: rrsun          ! An unused temporary factor related

  ! Parameters that properly belong exclusively to ice_thm.	  ! Parameters that properly belong exclusively to ice_thm.
  real :: massless_ice_enth, massless_snow_enth ! Enthalpy fi	  real :: massless_ice_enth, massless_snow_enth ! Enthalpy fi
  real :: massless_ice_salin  ! A salinity fill value [S ~> p	  real :: massless_ice_salin  ! A salinity fill value [S ~> p

  real, allocatable, dimension(:,:) :: &			  real, allocatable, dimension(:,:) :: &
    h_ice_input, dummy   ! Temporary arrays.			    h_ice_input, dummy   ! Temporary arrays.
  real, allocatable, dimension(:,:) :: &			  real, allocatable, dimension(:,:) :: &
    str_x, str_y, stress_mag ! Temporary stress arrays		    str_x, str_y, stress_mag ! Temporary stress arrays

  real :: g_Earth        !   The gravitational acceleration [	  real :: g_Earth        !   The gravitational acceleration [
  real :: ice_bulk_salin ! The globally constant sea ice bulk	  real :: ice_bulk_salin ! The globally constant sea ice bulk
                         ! that is used to calculate the ocea	                         ! that is used to calculate the ocea
  real :: ice_rel_salin  ! The initial bulk salinity of sea-i	  real :: ice_rel_salin  ! The initial bulk salinity of sea-i
                         ! salinity of the water from which i	                         ! salinity of the water from which i
  real :: coszen_IC      ! A constant value that is used to i	  real :: coszen_IC      ! A constant value that is used to i
                         ! coszen if it is not read from a re	                         ! coszen if it is not read from a re
                         ! negative number to use the time an	                         ! negative number to use the time an
  real :: rho_ice        ! The nominal density of sea ice [R 	  real :: rho_ice        ! The nominal density of sea ice [R 
  real :: rho_snow       ! The nominal density of snow [R ~> 	  real :: rho_snow       ! The nominal density of snow [R ~> 
  real :: rho_Ocean      ! The nominal density of seawater [R	  real :: rho_Ocean      ! The nominal density of seawater [R
  real :: kmelt          ! A constant that is used in the cal	  real :: kmelt          ! A constant that is used in the cal
                         ! flux [Q R Z T-1 C-1 ~> W m-2 degC-	                         ! flux [Q R Z T-1 C-1 ~> W m-2 degC-
                         ! the turbulence in the under-ice oc	                         ! the turbulence in the under-ice oc
                         ! depth of the reported value of t_o	                         ! depth of the reported value of t_o
  real :: opm_dflt       ! The default value for ocean_part_m	  real :: opm_dflt       ! The default value for ocean_part_m
                         ! minimum value for the fractional o	                         ! minimum value for the fractional o
                         ! area.  With redo_fast_update, this	                         ! area.  With redo_fast_update, this
                         ! that the open ocean fluxes can be 	                         ! that the open ocean fluxes can be 
                         ! interpolation across categories; o	                         ! interpolation across categories; o
                         ! to reduce the number of categories	                         ! to reduce the number of categories
                         ! In ice/ocean models, sufficiently 	                         ! In ice/ocean models, sufficiently 
                         ! change answers, but in coupled mod	                         ! change answers, but in coupled mod
                         ! answers at roundoff.			                         ! answers at roundoff.

  integer :: CatIce, NkIce, isd, ied, jsd, jed			  integer :: CatIce, NkIce, isd, ied, jsd, jed
  integer :: write_geom     ! A flag indicating whether to wr	  integer :: write_geom     ! A flag indicating whether to wr
                            ! new runs (1), both new runs and	                            ! new runs (1), both new runs and
  logical :: nudge_sea_ice  ! If true, nudge sea ice concentr	  logical :: nudge_sea_ice  ! If true, nudge sea ice concentr
  logical :: transmute_ice  ! If true, allow ice to be transm	  logical :: transmute_ice  ! If true, allow ice to be transm
                            ! spatially varying rate as a for	                            ! spatially varying rate as a for
  logical :: atmos_winds, slp2ocean				  logical :: atmos_winds, slp2ocean
  logical :: do_icebergs, pass_iceberg_area_to_ocean		  logical :: do_icebergs, pass_iceberg_area_to_ocean
  logical :: pass_stress_mag					  logical :: pass_stress_mag
  logical :: do_ridging						  logical :: do_ridging
  logical :: specified_ice    ! If true, the ice is specified	  logical :: specified_ice    ! If true, the ice is specified
  logical :: Cgrid_dyn						  logical :: Cgrid_dyn
  logical :: new_sim     ! If true, this is a new simulation,	  logical :: new_sim     ! If true, this is a new simulation,
                         ! the presence or absence of a named	                         ! the presence or absence of a named
  logical :: slab_ice    ! If true, use the very old slab ice	  logical :: slab_ice    ! If true, use the very old slab ice
                         ! with effectively zero heat capacit	                         ! with effectively zero heat capacit
  logical :: debug, debug_slow, debug_fast, bounds_check	  logical :: debug, debug_slow, debug_fast, bounds_check
  logical :: do_sun_angle_for_alb, add_diurnal_sw		  logical :: do_sun_angle_for_alb, add_diurnal_sw
  logical :: init_coszen, init_Tskin, init_rough		  logical :: init_coszen, init_Tskin, init_rough
  logical :: Eulerian_tsurf   ! If true, use previous calcula	  logical :: Eulerian_tsurf   ! If true, use previous calcula
                              ! surface skin temperature for 	                              ! surface skin temperature for 
                              ! atmospheric time stepping, in	                              ! atmospheric time stepping, in
                              ! tsurf values from other categ	                              ! tsurf values from other categ
  logical :: write_geom_files ! If true, write out the grid g	  logical :: write_geom_files ! If true, write out the grid g
  logical :: symmetric        ! If true, use symmetric memory	  logical :: symmetric        ! If true, use symmetric memory
  logical :: global_indexing  ! If true use global horizontal	  logical :: global_indexing  ! If true use global horizontal
                              ! of having the data domain on 	                              ! of having the data domain on 
  integer :: first_direction  ! An integer that indicates whi	  integer :: first_direction  ! An integer that indicates whi
                              ! updated first in directionall	                              ! updated first in directionall
                              ! calculation.  This can be alt	                              ! calculation.  This can be alt
                              ! of the run via calls to set_f	                              ! of the run via calls to set_f
  logical :: fast_ice_PE      ! If true, fast ice processes a	  logical :: fast_ice_PE      ! If true, fast ice processes a
  logical :: slow_ice_PE      ! If true, slow ice processes a	  logical :: slow_ice_PE      ! If true, slow ice processes a
  logical :: single_IST       ! If true, fCS%IST and sCS%IST 	  logical :: single_IST       ! If true, fCS%IST and sCS%IST 
  logical :: interp_fluxes    ! If true, interpolate a linear	  logical :: interp_fluxes    ! If true, interpolate a linear
                              ! fast fluxes into arealess cat	                              ! fast fluxes into arealess cat
  logical :: redo_fast_update ! If true, recalculate the ther	  logical :: redo_fast_update ! If true, recalculate the ther
                              ! dynamics on the slowly evolvi	                              ! dynamics on the slowly evolvi
                              ! copying over the slow ice sta	                              ! copying over the slow ice sta
  logical :: do_mask_restart  ! If true, apply the scaling an	  logical :: do_mask_restart  ! If true, apply the scaling an
                              ! mH_pond, t_surf, t_skin, sal_	                              ! mH_pond, t_surf, t_skin, sal_
                              ! after a restart. However this	                              ! after a restart. However this
                              ! after a restart.Provide a swi	                              ! after a restart.Provide a swi
  logical :: recategorize_ice ! If true, adjust the distribut	  logical :: recategorize_ice ! If true, adjust the distribut
                              ! categories after initializati	                              ! categories after initializati
  logical :: use_oib_sym				      <
  logical :: Verona						  logical :: Verona
  logical :: Concurrent						  logical :: Concurrent
  logical :: read_aux_restart					  logical :: read_aux_restart
  logical :: split_restart_files				  logical :: split_restart_files
  logical :: is_restart = .false.				  logical :: is_restart = .false.
  character(len=16) :: stagger, dflt_stagger			  character(len=16) :: stagger, dflt_stagger
  type(ice_OBC_type), pointer :: OBC_in => NULL()		  type(ice_OBC_type), pointer :: OBC_in => NULL()

  if (associated(Ice%sCS)) then ; if (associated(Ice%sCS%IST)	  if (associated(Ice%sCS)) then ; if (associated(Ice%sCS%IST)
    call SIS_error(WARNING, "ice_model_init called with an as	    call SIS_error(WARNING, "ice_model_init called with an as
                    "Ice%sCS%Ice_state structure. Model is al	                    "Ice%sCS%Ice_state structure. Model is al
    return							    return
  endif ; endif							  endif ; endif

  ! For now, both fast and slow processes occur on all sea-ic	  ! For now, both fast and slow processes occur on all sea-ic
  fast_ice_PE = .true. ; slow_ice_PE = .true.			  fast_ice_PE = .true. ; slow_ice_PE = .true.
  Verona = .false. ; if (present(Verona_coupler)) Verona = Ve	  Verona = .false. ; if (present(Verona_coupler)) Verona = Ve
  if (Verona) call SIS_error(FATAL, "SIS2 no longer works wit	  if (Verona) call SIS_error(FATAL, "SIS2 no longer works wit
  fast_ice_PE = Ice%fast_ice_pe ; slow_ice_PE = Ice%slow_ice_	  fast_ice_PE = Ice%fast_ice_pe ; slow_ice_PE = Ice%slow_ice_
  Concurrent = .false. ; if (present(Concurrent_atm)) Concurr	  Concurrent = .false. ; if (present(Concurrent_atm)) Concurr

  ! Open the parameter file.					  ! Open the parameter file.
  if (fast_ice_PE.eqv.slow_ice_PE) then				  if (fast_ice_PE.eqv.slow_ice_PE) then
    call Get_SIS_Input(param_file, dirs, check_params=.true.,	    call Get_SIS_Input(param_file, dirs, check_params=.true.,
    call Get_SIS_Input(param_file, dirs, check_params=.false.	    call Get_SIS_Input(param_file, dirs, check_params=.false.
  elseif (slow_ice_PE) then					  elseif (slow_ice_PE) then
    call Get_SIS_Input(param_file, dirs, check_params=.true.,	    call Get_SIS_Input(param_file, dirs, check_params=.true.,
  elseif (fast_ice_PE) then					  elseif (fast_ice_PE) then
    call Get_SIS_Input(param_file, dirs, check_params=.false.	    call Get_SIS_Input(param_file, dirs, check_params=.false.
  endif								  endif

  call callTree_enter("ice_model_init(), ice_model.F90")	  call callTree_enter("ice_model_init(), ice_model.F90")

  ! Read all relevant parameters and write them to the model 	  ! Read all relevant parameters and write them to the model 
  call log_version(param_file, mdl, version, "")		  call log_version(param_file, mdl, version, "")

  ! Determining the internal unit scaling factors for this ru	  ! Determining the internal unit scaling factors for this ru
  call unit_scaling_init(param_file, US)			  call unit_scaling_init(param_file, US)

  call get_param(param_file, mdl, "SPECIFIED_ICE", specified_	  call get_param(param_file, mdl, "SPECIFIED_ICE", specified_
                 "If true, the ice is specified and there is 	                 "If true, the ice is specified and there is 
                 default=.false.)				                 default=.false.)
  call get_param(param_file, mdl, "CGRID_ICE_DYNAMICS", Cgrid	  call get_param(param_file, mdl, "CGRID_ICE_DYNAMICS", Cgrid
                 "If true, use a C-grid discretization of the	                 "If true, use a C-grid discretization of the
                 "dynamics; if false use a B-grid discretizat	                 "dynamics; if false use a B-grid discretizat
                 default=.true.)				                 default=.true.)
  if (specified_ice) then					  if (specified_ice) then
    slab_ice = .true.						    slab_ice = .true.
    call log_param(param_file, mdl, "USE_SLAB_ICE", slab_ice,	    call log_param(param_file, mdl, "USE_SLAB_ICE", slab_ice,
                 "Use the very old slab-style ice.  With SPEC	                 "Use the very old slab-style ice.  With SPEC
                 "USE_SLAB_ICE is always true.")		                 "USE_SLAB_ICE is always true.")
  else								  else
    call get_param(param_file, mdl, "USE_SLAB_ICE", slab_ice,	    call get_param(param_file, mdl, "USE_SLAB_ICE", slab_ice,
                 "If true, use the very old slab-style ice.",	                 "If true, use the very old slab-style ice.",
  endif								  endif
  call get_param(param_file, mdl, "SINGLE_ICE_STATE_TYPE", si	  call get_param(param_file, mdl, "SINGLE_ICE_STATE_TYPE", si
                 "If true, the fast and slow portions of the 	                 "If true, the fast and slow portions of the 
                 "single common ice_state_type.  Otherwise th	                 "single common ice_state_type.  Otherwise th
                 "different ice_state_types that need to be e	                 "different ice_state_types that need to be e
                 "copied back and forth.", default=.true.)	                 "copied back and forth.", default=.true.)
  call get_param(param_file, mdl, "EULERIAN_TSURF", Eulerian_	  call get_param(param_file, mdl, "EULERIAN_TSURF", Eulerian_
                 "If true, use previous calculations of the i	                 "If true, use previous calculations of the i
                 "skin temperature for tsurf at the start of 	                 "skin temperature for tsurf at the start of 
                 "time stepping, including interpolating betw	                 "time stepping, including interpolating betw
                 "values from other categories in the same lo	                 "values from other categories in the same lo

  call obsolete_logical(param_file, "SIS1_5L_THERMODYNAMICS",	  call obsolete_logical(param_file, "SIS1_5L_THERMODYNAMICS",
  call obsolete_logical(param_file, "INTERSPERSED_ICE_THERMO"	  call obsolete_logical(param_file, "INTERSPERSED_ICE_THERMO"
  call obsolete_logical(param_file, "AREA_WEIGHTED_STRESSES",	  call obsolete_logical(param_file, "AREA_WEIGHTED_STRESSES",

  dflt_stagger = "B" ; if (Cgrid_dyn) dflt_stagger = "C"	  dflt_stagger = "B" ; if (Cgrid_dyn) dflt_stagger = "C"
  call get_param(param_file, mdl, "ICE_OCEAN_STRESS_STAGGER",	  call get_param(param_file, mdl, "ICE_OCEAN_STRESS_STAGGER",
                 "A case-insensitive character string to indi	                 "A case-insensitive character string to indi
                 "staggering of the stress field on the ocean	                 "staggering of the stress field on the ocean
                 "returned to the coupler.  Valid values incl	                 "returned to the coupler.  Valid values incl
                 "'A', 'B', or 'C', with a default that follo	                 "'A', 'B', or 'C', with a default that follo
                 "value of CGRID_ICE_DYNAMICS.", default=dflt	                 "value of CGRID_ICE_DYNAMICS.", default=dflt
  call get_param(param_file, mdl, "USE_OCEAN_ICE_bndry_sym",  |
                 "If true, the ocean surface velocity in the  <
                 "boundary will be symmetric. Otherwise, velo <
                 "south and east edges of the domain will inc <
                 "is false, but reccomended true when using S <
                 default=.false.)			      <
                 					      <
  ! Rho_ocean is not actually used here, but it used from lat	  ! Rho_ocean is not actually used here, but it used from lat
  ! calls in other modules.  This call is here to avoid chang	  ! calls in other modules.  This call is here to avoid chang
  ! the entries in the SIS_parameter_doc files.			  ! the entries in the SIS_parameter_doc files.
  call get_param(param_file, mdl, "RHO_OCEAN", Rho_ocean, &	  call get_param(param_file, mdl, "RHO_OCEAN", Rho_ocean, &
                 "The nominal density of sea water as used by	                 "The nominal density of sea water as used by
                 units="kg m-3", default=1030.0, scale=US%kg_	                 units="kg m-3", default=1030.0, scale=US%kg_
  call get_param(param_file, mdl, "RHO_ICE", Rho_ice, &		  call get_param(param_file, mdl, "RHO_ICE", Rho_ice, &
                 "The nominal density of sea ice as used by S	                 "The nominal density of sea ice as used by S
                 units="kg m-3", default=905.0, scale=US%kg_m	                 units="kg m-3", default=905.0, scale=US%kg_m
  call get_param(param_file, mdl, "RHO_SNOW", Rho_snow, &	  call get_param(param_file, mdl, "RHO_SNOW", Rho_snow, &
                 "The nominal density of snow as used by SIS.	                 "The nominal density of snow as used by SIS.
                 units="kg m-3", default=330.0, scale=US%kg_m	                 units="kg m-3", default=330.0, scale=US%kg_m

  call get_param(param_file, mdl, "G_EARTH", g_Earth, &		  call get_param(param_file, mdl, "G_EARTH", g_Earth, &
                 "The gravitational acceleration of the Earth	                 "The gravitational acceleration of the Earth
                 units="m s-2", default = 9.80, scale=US%m_s_	                 units="m s-2", default = 9.80, scale=US%m_s_

  call get_param(param_file, mdl, "MOMENTUM_ROUGH_ICE", mom_r	  call get_param(param_file, mdl, "MOMENTUM_ROUGH_ICE", mom_r
                 "The default momentum roughness length scale	                 "The default momentum roughness length scale
                 units="m", default=1.0e-4)			                 units="m", default=1.0e-4)
  call get_param(param_file, mdl, "HEAT_ROUGH_ICE", heat_roug	  call get_param(param_file, mdl, "HEAT_ROUGH_ICE", heat_roug
                 "The default roughness length scale for the 	                 "The default roughness length scale for the 
                 "transfer of heat into the ocean.", units="m	                 "transfer of heat into the ocean.", units="m

  call get_param(param_file, mdl, "CONSTANT_COSZEN_IC", cosze	  call get_param(param_file, mdl, "CONSTANT_COSZEN_IC", cosze
                 "A constant value to use to initialize the c	                 "A constant value to use to initialize the c
                 "the solar zenith angle for the first radiat	                 "the solar zenith angle for the first radiat
                 "or a negative number to use the current tim	                 "or a negative number to use the current tim
                 units="nondim", default=-1.0)			                 units="nondim", default=-1.0)
  call get_param(param_file, mdl, "DT_RADIATION", dt_Rad_real	  call get_param(param_file, mdl, "DT_RADIATION", dt_Rad_real
                 "The time step with which the shortwave radi	                 "The time step with which the shortwave radi
                 "fields like albedos are updated.  Currently	                 "fields like albedos are updated.  Currently
                 "used to initialize albedos when there is no	                 "used to initialize albedos when there is no
                 units="s", default=time_type_to_real(Time_st	                 units="s", default=time_type_to_real(Time_st
  dt_Rad = real_to_time(dt_Rad_real)				  dt_Rad = real_to_time(dt_Rad_real)
  call get_param(param_file, mdl, "ICE_KMELT", kmelt, &		  call get_param(param_file, mdl, "ICE_KMELT", kmelt, &
                 "A constant giving the proportionality of th	                 "A constant giving the proportionality of th
                 "base heat flux to the tempature difference,	                 "base heat flux to the tempature difference,
                 "the product of the heat capacity per unit v	                 "the product of the heat capacity per unit v
                 "water times a molecular diffusive piston ve	                 "water times a molecular diffusive piston ve
                 units="W m-2 K-1", scale=US%W_m2_to_QRZ_T*US	                 units="W m-2 K-1", scale=US%W_m2_to_QRZ_T*US
  call obsolete_real(param_file, "SNOW_CONDUCT", warning_val=	  call obsolete_real(param_file, "SNOW_CONDUCT", warning_val=
  call get_param(param_file, mdl, "ICE_BOUNDS_CHECK", bounds_	  call get_param(param_file, mdl, "ICE_BOUNDS_CHECK", bounds_
                 "If true, periodically check the values of i	                 "If true, periodically check the values of i
                 "temperatures and thicknesses to ensure that	                 "temperatures and thicknesses to ensure that
                 "sensible, and issue warnings if they are no	                 "sensible, and issue warnings if they are no
                 "does not change answers, but can increase m	                 "does not change answers, but can increase m
                 default=.true.)				                 default=.true.)
  call get_param(param_file, mdl, "DEBUG", debug, &		  call get_param(param_file, mdl, "DEBUG", debug, &
                 "If true, write out verbose debugging data."	                 "If true, write out verbose debugging data."
                 default=.false., debuggingParam=.true.)	                 default=.false., debuggingParam=.true.)
  call get_param(param_file, mdl, "DEBUG_SLOW_ICE", debug_slo	  call get_param(param_file, mdl, "DEBUG_SLOW_ICE", debug_slo
                 "If true, write out verbose debugging data o	                 "If true, write out verbose debugging data o
                 default=debug, debuggingParam=.true.)		                 default=debug, debuggingParam=.true.)
  call get_param(param_file, mdl, "DEBUG_FAST_ICE", debug_fas	  call get_param(param_file, mdl, "DEBUG_FAST_ICE", debug_fas
                 "If true, write out verbose debugging data o	                 "If true, write out verbose debugging data o
                 default=debug, debuggingParam=.true.)		                 default=debug, debuggingParam=.true.)
  call get_param(param_file, mdl, "GLOBAL_INDEXING", global_i	  call get_param(param_file, mdl, "GLOBAL_INDEXING", global_i
                 "If true, use a global lateral indexing conv	                 "If true, use a global lateral indexing conv
                 "that corresponding points on different proc	                 "that corresponding points on different proc
                 "the same index. This does not work with sta	                 "the same index. This does not work with sta
                 default=.false., layoutParam=.true.)		                 default=.false., layoutParam=.true.)
#ifdef STATIC_MEMORY_						#ifdef STATIC_MEMORY_
  if (global_indexing) call SIS_error(FATAL, "ice_model_init:	  if (global_indexing) call SIS_error(FATAL, "ice_model_init:
       "GLOBAL_INDEXING can not be true with STATIC_MEMORY.")	       "GLOBAL_INDEXING can not be true with STATIC_MEMORY.")
#endif								#endif
  call get_param(param_file, mdl, "FIRST_DIRECTION", first_di	  call get_param(param_file, mdl, "FIRST_DIRECTION", first_di
                 "An integer that indicates which direction g	                 "An integer that indicates which direction g
                 "in parts of the code that use directionally	                 "in parts of the code that use directionally
                 "updates, with even numbers (or 0) used for 	                 "updates, with even numbers (or 0) used for 
                 "and odd numbers used for y-first.", default	                 "and odd numbers used for y-first.", default

  call get_param(param_file, mdl, "ICE_SEES_ATMOS_WINDS", atm	  call get_param(param_file, mdl, "ICE_SEES_ATMOS_WINDS", atm
                 "If true, the sea ice is being given wind st	                 "If true, the sea ice is being given wind st
                 "the atmospheric sign convention, and need t	                 "the atmospheric sign convention, and need t
                 default=.true.)				                 default=.true.)
  call get_param(param_file, mdl, "ICE_BULK_SALINITY", ice_bu	  call get_param(param_file, mdl, "ICE_BULK_SALINITY", ice_bu
                 "The fixed bulk salinity of sea ice.", units	                 "The fixed bulk salinity of sea ice.", units
                 default=4.0, do_not_log=.true.)		                 default=4.0, do_not_log=.true.)
  call get_param(param_file, mdl, "ICE_RELATIVE_SALINITY", ic	  call get_param(param_file, mdl, "ICE_RELATIVE_SALINITY", ic
                 "The initial salinity of sea ice as a fracti	                 "The initial salinity of sea ice as a fracti
                 "salinity of the seawater from which it form	                 "salinity of the seawater from which it form
                 units = "nondim", default=0.0, do_not_log=.t	                 units = "nondim", default=0.0, do_not_log=.t
  if ((ice_bulk_salin < 0.0) .or. (ice_rel_salin > 0.0)) ice_	  if ((ice_bulk_salin < 0.0) .or. (ice_rel_salin > 0.0)) ice_

  call get_param(param_file, mdl, "APPLY_SLP_TO_OCEAN", slp2o	  call get_param(param_file, mdl, "APPLY_SLP_TO_OCEAN", slp2o
                 "If true, apply the atmospheric sea level pr	                 "If true, apply the atmospheric sea level pr
                 default=.false.)				                 default=.false.)
  call get_param(param_file, mdl, "PASS_STRESS_MAG_TO_OCEAN",	  call get_param(param_file, mdl, "PASS_STRESS_MAG_TO_OCEAN",
                 "If true, provide the time and area weighted	                 "If true, provide the time and area weighted
                 "of the stresses on the ocean to the ocean."	                 "of the stresses on the ocean to the ocean."
  call get_param(param_file, mdl, "DO_ICEBERGS", do_icebergs,	  call get_param(param_file, mdl, "DO_ICEBERGS", do_icebergs,
                 "If true, call the iceberg module.", default	                 "If true, call the iceberg module.", default
  if (do_icebergs) then						  if (do_icebergs) then
    call get_param(param_file, mdl, "PASS_ICEBERG_AREA_TO_OCE	    call get_param(param_file, mdl, "PASS_ICEBERG_AREA_TO_OCE
                 "If true, iceberg area is passed through cou	                 "If true, iceberg area is passed through cou
  else ; pass_iceberg_area_to_ocean = .false. ; endif		  else ; pass_iceberg_area_to_ocean = .false. ; endif

  call get_param(param_file, mdl, "ADD_DIURNAL_SW", add_diurn	  call get_param(param_file, mdl, "ADD_DIURNAL_SW", add_diurn
                 "If true, add a synthetic diurnal cycle to t	                 "If true, add a synthetic diurnal cycle to t
                 default=.false.)				                 default=.false.)
  call get_param(param_file, mdl, "DO_SUN_ANGLE_FOR_ALB", do_	  call get_param(param_file, mdl, "DO_SUN_ANGLE_FOR_ALB", do_
                 "If true, find the sun angle for calculating	                 "If true, find the sun angle for calculating
                 "albedo within the sea ice model.", default=	                 "albedo within the sea ice model.", default=
  call get_param(param_file, mdl, "DO_RIDGING", do_ridging, &	  call get_param(param_file, mdl, "DO_RIDGING", do_ridging, &
                 "If true, call the ridging routines.", defau	                 "If true, call the ridging routines.", defau

  call get_param(param_file, mdl, "RESTARTFILE", restart_file	  call get_param(param_file, mdl, "RESTARTFILE", restart_file
                 "The name of the restart file.", default="ic	                 "The name of the restart file.", default="ic
  if (fast_ice_PE.eqv.slow_ice_PE) then				  if (fast_ice_PE.eqv.slow_ice_PE) then
    call get_param(param_file, mdl, "FAST_ICE_RESTARTFILE", f	    call get_param(param_file, mdl, "FAST_ICE_RESTARTFILE", f
                   "The name of the restart file for those el	                   "The name of the restart file for those el
                   "the sea ice that are handled by the fast 	                   "the sea ice that are handled by the fast 
  else								  else
    call get_param(param_file, mdl, "FAST_ICE_RESTARTFILE", f	    call get_param(param_file, mdl, "FAST_ICE_RESTARTFILE", f
                   "The name of the restart file for those el	                   "The name of the restart file for those el
                   "the sea ice that are handled by the fast 	                   "the sea ice that are handled by the fast 
                   default="ice_model_fast.res.nc")		                   default="ice_model_fast.res.nc")
  endif								  endif
  call get_param(param_file, mdl, "APPLY_MASKS_AFTER_RESTART"	  call get_param(param_file, mdl, "APPLY_MASKS_AFTER_RESTART"
                 "If true, applies masks to mH_ice,mH_snow an	                 "If true, applies masks to mH_ice,mH_snow an
                  default=.true.)				                  default=.true.)

  call get_param(param_file, mdl, "MASSLESS_ICE_ENTH", massle	  call get_param(param_file, mdl, "MASSLESS_ICE_ENTH", massle
                 "The ice enthalpy fill value for massless ca	                 "The ice enthalpy fill value for massless ca
                 units="J kg-1", default=0.0, scale=US%J_kg_t	                 units="J kg-1", default=0.0, scale=US%J_kg_t
  call get_param(param_file, mdl, "MASSLESS_SNOW_ENTH", massl	  call get_param(param_file, mdl, "MASSLESS_SNOW_ENTH", massl
                 "The snow enthalpy fill value for massless c	                 "The snow enthalpy fill value for massless c
                 units="J kg-1", default=0.0, scale=US%J_kg_t	                 units="J kg-1", default=0.0, scale=US%J_kg_t
  call get_param(param_file, mdl, "MASSLESS_ICE_SALIN", massl	  call get_param(param_file, mdl, "MASSLESS_ICE_SALIN", massl
                 "The ice salinity fill value for massless ca	                 "The ice salinity fill value for massless ca
                 units="g kg-1", default=0.0, scale=US%ppt_to	                 units="g kg-1", default=0.0, scale=US%ppt_to
  call get_param(param_file, "MOM", "WRITE_GEOM", write_geom,	  call get_param(param_file, "MOM", "WRITE_GEOM", write_geom,
                 "If =0, never write the geometry and vertica	                 "If =0, never write the geometry and vertica
                 "If =1, write the geometry and vertical grid	                 "If =1, write the geometry and vertical grid
                 "a new simulation. If =2, always write the g	                 "a new simulation. If =2, always write the g
                 "vertical grid files. Other values are inval	                 "vertical grid files. Other values are inval
  if (write_geom<0 .or. write_geom>2) call SIS_error(FATAL,"S	  if (write_geom<0 .or. write_geom>2) call SIS_error(FATAL,"S
         "WRITE_GEOM must be equal to 0, 1 or 2.")		         "WRITE_GEOM must be equal to 0, 1 or 2.")
  call get_param(param_file, "MOM", "INTERPOLATE_FLUXES", int	  call get_param(param_file, "MOM", "INTERPOLATE_FLUXES", int
                 "If true, interpolate a linearized version o	                 "If true, interpolate a linearized version o
                 "fluxes into arealess categories.", default=	                 "fluxes into arealess categories.", default=
  call get_param(param_file, "MOM", "REDO_FAST_ICE_UPDATE", r	  call get_param(param_file, "MOM", "REDO_FAST_ICE_UPDATE", r
                 "If true, recalculate the thermal updates fr	                 "If true, recalculate the thermal updates fr
                 "dynamics on the slowly evolving ice state, 	                 "dynamics on the slowly evolving ice state, 
                 "copying over the slow ice state to the fast	                 "copying over the slow ice state to the fast

  call get_param(param_file, mdl, "NUDGE_SEA_ICE", nudge_sea_	  call get_param(param_file, mdl, "NUDGE_SEA_ICE", nudge_sea_
                 "If true, constrain the sea ice concentratio	                 "If true, constrain the sea ice concentratio
                 default=.false., do_not_log=.true.) ! Defer 	                 default=.false., do_not_log=.true.) ! Defer 
  call get_param(param_file, mdl, "TRANSMUTE_SEA_ICE", transm	  call get_param(param_file, mdl, "TRANSMUTE_SEA_ICE", transm
                 "If true, allow ice to be transmuted directl	                 "If true, allow ice to be transmuted directl
                 "varying rate as a form of outflow open boun	                 "varying rate as a form of outflow open boun
                 default=.false., do_not_log=.true.) ! Defer 	                 default=.false., do_not_log=.true.) ! Defer 


  nCat_dflt = 5 ; if (slab_ice) nCat_dflt = 1			  nCat_dflt = 5 ; if (slab_ice) nCat_dflt = 1
  opm_dflt = 0.0 ; if (redo_fast_update) opm_dflt = 1.0e-40	  opm_dflt = 0.0 ; if (redo_fast_update) opm_dflt = 1.0e-40
#ifdef SYMMETRIC_MEMORY_					#ifdef SYMMETRIC_MEMORY_
  symmetric = .true.						  symmetric = .true.
#else								#else
  symmetric = .false.						  symmetric = .false.
#endif								#endif

  call SIS_debugging_init(param_file)				  call SIS_debugging_init(param_file)

  ! Interpret and do error checking on some of the parameters	  ! Interpret and do error checking on some of the parameters
  split_restart_files = (trim(restart_file) /= trim(fast_rest	  split_restart_files = (trim(restart_file) /= trim(fast_rest
  if ((fast_ice_PE.neqv.slow_ice_PE) .and. .not.split_restart	  if ((fast_ice_PE.neqv.slow_ice_PE) .and. .not.split_restart
    call SIS_error(FATAL, "The fast ice restart file must be 	    call SIS_error(FATAL, "The fast ice restart file must be 
           "standard ice restart file when there are separate	           "standard ice restart file when there are separate
           "Choose different values of RESTARTFILE and FAST_I	           "Choose different values of RESTARTFILE and FAST_I
  endif								  endif

  if (fast_ice_PE.neqv.slow_ice_PE) single_IST = .false.	  if (fast_ice_PE.neqv.slow_ice_PE) single_IST = .false.

  if (uppercase(stagger(1:1)) == 'A') then ; Ice%flux_uv_stag	  if (uppercase(stagger(1:1)) == 'A') then ; Ice%flux_uv_stag
  elseif (uppercase(stagger(1:1)) == 'B') then ; Ice%flux_uv_	  elseif (uppercase(stagger(1:1)) == 'B') then ; Ice%flux_uv_
  elseif (uppercase(stagger(1:1)) == 'C') then ; Ice%flux_uv_	  elseif (uppercase(stagger(1:1)) == 'C') then ; Ice%flux_uv_
  else ; call SIS_error(FATAL,"ice_model_init: ICE_OCEAN_STRE	  else ; call SIS_error(FATAL,"ice_model_init: ICE_OCEAN_STRE
                        trim(stagger)//" is invalid.") ; endi	                        trim(stagger)//" is invalid.") ; endi

  Ice%use_oib_sym = use_oib_sym				      <
  Ice%Time = Time						  Ice%Time = Time

  !   Now that all top-level sea-ice parameters have been rea	  !   Now that all top-level sea-ice parameters have been rea
  ! various structures and register fields for restarts.	  ! various structures and register fields for restarts.
  if (slow_ice_PE) then						  if (slow_ice_PE) then
    if (.not.associated(Ice%sCS)) allocate(Ice%sCS)		    if (.not.associated(Ice%sCS)) allocate(Ice%sCS)
    if (.not.associated(Ice%sCS%IG)) allocate(Ice%sCS%IG)	    if (.not.associated(Ice%sCS%IG)) allocate(Ice%sCS%IG)
    if (.not.associated(Ice%sCS%IST)) allocate(Ice%sCS%IST)	    if (.not.associated(Ice%sCS%IST)) allocate(Ice%sCS%IST)
    Ice%sCS%US => US						    Ice%sCS%US => US
    Ice%sCS%Time = Time						    Ice%sCS%Time = Time

    ! Set some pointers for convenience.			    ! Set some pointers for convenience.
    sIST => Ice%sCS%IST ; sIG => Ice%sCS%IG			    sIST => Ice%sCS%IST ; sIG => Ice%sCS%IG
    sIST%Cgrid_dyn = Cgrid_dyn					    sIST%Cgrid_dyn = Cgrid_dyn

    Ice%sCS%do_icebergs = do_icebergs				    Ice%sCS%do_icebergs = do_icebergs
    Ice%sCS%pass_iceberg_area_to_ocean = pass_iceberg_area_to	    Ice%sCS%pass_iceberg_area_to_ocean = pass_iceberg_area_to
    Ice%sCS%pass_stress_mag = pass_stress_mag			    Ice%sCS%pass_stress_mag = pass_stress_mag
    Ice%sCS%slab_ice = slab_ice					    Ice%sCS%slab_ice = slab_ice
    Ice%sCS%specified_ice = specified_ice			    Ice%sCS%specified_ice = specified_ice
    Ice%sCS%Cgrid_dyn = Cgrid_dyn				    Ice%sCS%Cgrid_dyn = Cgrid_dyn
    Ice%sCS%redo_fast_update = redo_fast_update			    Ice%sCS%redo_fast_update = redo_fast_update
    Ice%sCS%bounds_check = bounds_check				    Ice%sCS%bounds_check = bounds_check
    Ice%sCS%debug = debug_slow					    Ice%sCS%debug = debug_slow

    ! Set up the ice-specific grid describing categories and 	    ! Set up the ice-specific grid describing categories and 
    call set_ice_grid(sIG, US, param_file, nCat_dflt, ocean_p	    call set_ice_grid(sIG, US, param_file, nCat_dflt, ocean_p
    if (slab_ice) sIG%CatIce = 1 ! open water and ice ... but	    if (slab_ice) sIG%CatIce = 1 ! open water and ice ... but
    CatIce = sIG%CatIce ; NkIce = sIG%NkIce			    CatIce = sIG%CatIce ; NkIce = sIG%NkIce
    call initialize_ice_categories(sIG, Rho_ice, US, param_fi	    call initialize_ice_categories(sIG, Rho_ice, US, param_fi


    ! Set up the domains and lateral grids.			    ! Set up the domains and lateral grids.
    if (.not.associated(Ice%sCS%G)) allocate(Ice%sCS%G)		    if (.not.associated(Ice%sCS%G)) allocate(Ice%sCS%G)
    sG => Ice%sCS%G						    sG => Ice%sCS%G

    ! Set up the MOM_domain_type structures.			    ! Set up the MOM_domain_type structures.
#ifdef STATIC_MEMORY_						#ifdef STATIC_MEMORY_
    call MOM_domains_init(Ice%sCS%G%domain, param_file, symme	    call MOM_domains_init(Ice%sCS%G%domain, param_file, symme
              static_memory=.true., NIHALO=NIHALO_, NJHALO=NJ	              static_memory=.true., NIHALO=NIHALO_, NJHALO=NJ
              NIGLOBAL=NIGLOBAL_, NJGLOBAL=NJGLOBAL_, NIPROC=	              NIGLOBAL=NIGLOBAL_, NJGLOBAL=NJGLOBAL_, NIPROC=
              NJPROC=NJPROC_, domain_name="ice model", includ	              NJPROC=NJPROC_, domain_name="ice model", includ
#else								#else
    call MOM_domains_init(Ice%sCS%G%domain, param_file, symme	    call MOM_domains_init(Ice%sCS%G%domain, param_file, symme
             domain_name="ice model", include_name="SIS2_memo	             domain_name="ice model", include_name="SIS2_memo
#endif								#endif
    sGD => Ice%sCS%G%Domain					    sGD => Ice%sCS%G%Domain

    call callTree_waypoint("domains initialized (ice_model_in	    call callTree_waypoint("domains initialized (ice_model_in
    call hor_index_init(sGD, sHI, param_file, &			    call hor_index_init(sGD, sHI, param_file, &
                        local_indexing=.not.global_indexing)	                        local_indexing=.not.global_indexing)

    call create_dyn_horgrid(dG, sHI) !, bathymetry_at_vel=bat	    call create_dyn_horgrid(dG, sHI) !, bathymetry_at_vel=bat
    call clone_MOM_domain(sGD, dG%Domain)			    call clone_MOM_domain(sGD, dG%Domain)

    ! Set up the restart file and determine whether this is a	    ! Set up the restart file and determine whether this is a
    call set_domain(sGD%mpp_domain)				    call set_domain(sGD%mpp_domain)
    if (.not.associated(Ice%Ice_restart)) &			    if (.not.associated(Ice%Ice_restart)) &
      call SIS_restart_init(Ice%Ice_restart, restart_file, sG	      call SIS_restart_init(Ice%Ice_restart, restart_file, sG
    new_sim = determine_is_new_run(dirs%input_filename, dirs%	    new_sim = determine_is_new_run(dirs%input_filename, dirs%
    write_geom_files = ((write_geom==2) .or. ((write_geom==1)	    write_geom_files = ((write_geom==2) .or. ((write_geom==1)

    ! Set the bathymetry, Coriolis parameter, open channel wi	    ! Set the bathymetry, Coriolis parameter, open channel wi
    call SIS_initialize_fixed(dG, US, param_file, write_geom_	    call SIS_initialize_fixed(dG, US, param_file, write_geom_

    call set_hor_grid(sG, param_file, global_indexing=global_	    call set_hor_grid(sG, param_file, global_indexing=global_
    call copy_dyngrid_to_SIS_horgrid(dG, sG)			    call copy_dyngrid_to_SIS_horgrid(dG, sG)
    call destroy_dyn_horgrid(dG)				    call destroy_dyn_horgrid(dG)
    Ice%sCS%G%US => US						    Ice%sCS%G%US => US
    Ice%OBC => OBC_in						    Ice%OBC => OBC_in

  ! Allocate and register fields for restarts.			  ! Allocate and register fields for restarts.

    call ice_type_slow_reg_restarts(sGD%mpp_domain, CatIce, &	    call ice_type_slow_reg_restarts(sGD%mpp_domain, CatIce, &
                      param_file, Ice, Ice%Ice_restart)		                      param_file, Ice, Ice%Ice_restart)

    call alloc_IST_arrays(sHI, sIG, US, sIST, omit_tsurf=Eule	    call alloc_IST_arrays(sHI, sIG, US, sIST, omit_tsurf=Eule
    call ice_state_register_restarts(sIST, sG, sIG, US, Ice%I	    call ice_state_register_restarts(sIST, sG, sIG, US, Ice%I
    call register_unit_conversion_restarts(Ice%sCS%US, Ice%Ic	    call register_unit_conversion_restarts(Ice%sCS%US, Ice%Ic

    call alloc_ocean_sfc_state(Ice%sCS%OSS, sHI, sIST%Cgrid_d	    call alloc_ocean_sfc_state(Ice%sCS%OSS, sHI, sIST%Cgrid_d
    Ice%sCS%OSS%kmelt = kmelt					    Ice%sCS%OSS%kmelt = kmelt

    call alloc_simple_OSS(Ice%sCS%sOSS, sHI, gas_fields_ocn)	    call alloc_simple_OSS(Ice%sCS%sOSS, sHI, gas_fields_ocn)

    call alloc_ice_ocean_flux(Ice%sCS%IOF, sHI, do_stress_mag	    call alloc_ice_ocean_flux(Ice%sCS%IOF, sHI, do_stress_mag
                              do_iceberg_fields=Ice%sCS%do_ic	                              do_iceberg_fields=Ice%sCS%do_ic
    Ice%sCS%IOF%slp2ocean = slp2ocean				    Ice%sCS%IOF%slp2ocean = slp2ocean
    Ice%sCS%IOF%flux_uv_stagger = Ice%flux_uv_stagger		    Ice%sCS%IOF%flux_uv_stagger = Ice%flux_uv_stagger
    call alloc_fast_ice_avg(Ice%sCS%FIA, sHI, sIG, interp_flu	    call alloc_fast_ice_avg(Ice%sCS%FIA, sHI, sIG, interp_flu

    if (Ice%sCS%redo_fast_update) then				    if (Ice%sCS%redo_fast_update) then
      call alloc_total_sfc_flux(Ice%sCS%TSF, sHI, gas_fluxes)	      call alloc_total_sfc_flux(Ice%sCS%TSF, sHI, gas_fluxes)
      call alloc_total_sfc_flux(Ice%sCS%XSF, sHI, gas_fluxes)	      call alloc_total_sfc_flux(Ice%sCS%XSF, sHI, gas_fluxes)
      call alloc_ice_rad(Ice%sCS%Rad, sHI, sIG)			      call alloc_ice_rad(Ice%sCS%Rad, sHI, sIG)
    endif							    endif

    if (.not.specified_ice) &					    if (.not.specified_ice) &
      call SIS_dyn_trans_register_restarts(sHI, sIG, param_fi	      call SIS_dyn_trans_register_restarts(sHI, sIG, param_fi
                                           Ice%Ice_restart)	                                           Ice%Ice_restart)

    call SIS_diag_mediator_init(sG, sIG, param_file, Ice%sCS%	    call SIS_diag_mediator_init(sG, sIG, param_file, Ice%sCS%
                                doc_file_dir = dirs%output_di	                                doc_file_dir = dirs%output_di
    call set_SIS_axes_info(sG, sIG, param_file, Ice%sCS%diag)	    call set_SIS_axes_info(sG, sIG, param_file, Ice%sCS%diag)

    call ice_thermo_init(param_file, sIST%ITV, US, init_EOS=n	    call ice_thermo_init(param_file, sIST%ITV, US, init_EOS=n

    ! Register tracers that will be advected around.		    ! Register tracers that will be advected around.
    call register_SIS_tracer_pair(sIST%enth_ice, NkIce, "enth	    call register_SIS_tracer_pair(sIST%enth_ice, NkIce, "enth
                                  sIST%enth_snow, 1, "enth_sn	                                  sIST%enth_snow, 1, "enth_sn
                                  sG, sIG, param_file, sIST%T	                                  sG, sIG, param_file, sIST%T
                                  massless_iceval=massless_ic	                                  massless_iceval=massless_ic
                                  massless_snowval=massless_s	                                  massless_snowval=massless_s

    if (ice_rel_salin > 0.0) then				    if (ice_rel_salin > 0.0) then
      call register_SIS_tracer(sIST%sal_ice, sG, sIG, NkIce, 	      call register_SIS_tracer(sIST%sal_ice, sG, sIG, NkIce, 
                               sIST%TrReg, snow_tracer=.false	                               sIST%TrReg, snow_tracer=.false
                               nonnegative=.true., conc_scale	                               nonnegative=.true., conc_scale
    endif							    endif

  !   Register any tracers that will be handled via tracer fl	  !   Register any tracers that will be handled via tracer fl
  ! restarts and advection.					  ! restarts and advection.
    call SIS_call_tracer_register(sG, sIG, param_file, Ice%sC	    call SIS_call_tracer_register(sG, sIG, param_file, Ice%sC
                                  Ice%sCS%diag, sIST%TrReg, I	                                  Ice%sCS%diag, sIST%TrReg, I

    ! Set a few final things to complete the setup of the gri	    ! Set a few final things to complete the setup of the gri
    sG%g_Earth = g_Earth					    sG%g_Earth = g_Earth
    call set_first_direction(sG, first_direction)		    call set_first_direction(sG, first_direction)
    call clone_MOM_domain(sGD, sG%domain_aux, symmetric=.fals	    call clone_MOM_domain(sGD, sG%domain_aux, symmetric=.fals
                          domain_name="ice model aux")		                          domain_name="ice model aux")

    ! Copy the ice model's domain into one with no halos that	    ! Copy the ice model's domain into one with no halos that
    ! publicly for use by the exchange grid.			    ! publicly for use by the exchange grid.
    call clone_MOM_domain(sGD, Ice%slow_domain_NH, halo_size=	    call clone_MOM_domain(sGD, Ice%slow_domain_NH, halo_size=
                          domain_name="ice_nohalo")		                          domain_name="ice_nohalo")

    ! Set the computational domain sizes using the ice model'	    ! Set the computational domain sizes using the ice model'
    isc = sHI%isc ; iec = sHI%iec ; jsc = sHI%jsc ; jec = sHI	    isc = sHI%isc ; iec = sHI%iec ; jsc = sHI%jsc ; jec = sHI
    i_off = LBOUND(Ice%area,1) - sHI%isc ; j_off = LBOUND(Ice	    i_off = LBOUND(Ice%area,1) - sHI%isc ; j_off = LBOUND(Ice
    do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off	    do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off
      Ice%area(i2,j2) = US%L_to_m**2 * sG%areaT(i,j) * sG%mas	      Ice%area(i2,j2) = US%L_to_m**2 * sG%areaT(i,j) * sG%mas
    enddo ; enddo						    enddo ; enddo

  endif ! slow_ice_PE						  endif ! slow_ice_PE

  !   Allocate the various structures and register fields for	  !   Allocate the various structures and register fields for
  ! to the fast ice processes.  This is interspersed between 	  ! to the fast ice processes.  This is interspersed between 
  ! registration calls and the actual reading of the restart 	  ! registration calls and the actual reading of the restart 
  ! might be a single common restart file being used, and bec	  ! might be a single common restart file being used, and bec
  ! state might use some structures that point to their count	  ! state might use some structures that point to their count
  ! ice state.							  ! ice state.
  if (fast_ice_PE) then						  if (fast_ice_PE) then
    if (.not.associated(Ice%fCS)) allocate(Ice%fCS)		    if (.not.associated(Ice%fCS)) allocate(Ice%fCS)
    if (.not.associated(Ice%fCS%IG)) allocate(Ice%fCS%IG)	    if (.not.associated(Ice%fCS%IG)) allocate(Ice%fCS%IG)
    Ice%fCS%Time = Time						    Ice%fCS%Time = Time

    if (single_IST .and. .not.redo_fast_update) then		    if (single_IST .and. .not.redo_fast_update) then
      Ice%fCS%IST => Ice%sCS%IST				      Ice%fCS%IST => Ice%sCS%IST
    else							    else
      if (.not.associated(Ice%fCS%IST)) allocate(Ice%fCS%IST)	      if (.not.associated(Ice%fCS%IST)) allocate(Ice%fCS%IST)
    endif							    endif

    Ice%fCS%US => US						    Ice%fCS%US => US

    if (single_IST) then					    if (single_IST) then
      Ice%fCS%G => Ice%sCS%G					      Ice%fCS%G => Ice%sCS%G
      fG => Ice%fCS%G						      fG => Ice%fCS%G
      fGD => Ice%fCS%G%Domain					      fGD => Ice%fCS%G%Domain
      fHI = sHI							      fHI = sHI
      Ice%fCS%FIA => Ice%sCS%FIA				      Ice%fCS%FIA => Ice%sCS%FIA
      Ice%fCS%sOSS => Ice%sCS%sOSS				      Ice%fCS%sOSS => Ice%sCS%sOSS
    else							    else
      ! Set up the domains and lateral grids.			      ! Set up the domains and lateral grids.
      Ice%fCS%IST%Cgrid_dyn = Cgrid_dyn				      Ice%fCS%IST%Cgrid_dyn = Cgrid_dyn
      if (.not.associated(Ice%fCS%G)) allocate(Ice%fCS%G)	      if (.not.associated(Ice%fCS%G)) allocate(Ice%fCS%G)
      fG => Ice%fCS%G						      fG => Ice%fCS%G

      ! Set up the MOM_domain_type structures.			      ! Set up the MOM_domain_type structures.
      call MOM_domains_init(Ice%fCS%G%domain, param_file, sym	      call MOM_domains_init(Ice%fCS%G%domain, param_file, sym
               domain_name="ice model fast", include_name="SI	               domain_name="ice model fast", include_name="SI
               static_memory=.false., NIHALO=0, NJHALO=0, par	               static_memory=.false., NIHALO=0, NJHALO=0, par
      fGD => Ice%fCS%G%Domain					      fGD => Ice%fCS%G%Domain

      call callTree_waypoint("domains initialized (ice_model_	      call callTree_waypoint("domains initialized (ice_model_
      call hor_index_init(fGD, fHI, param_file, &		      call hor_index_init(fGD, fHI, param_file, &
                          local_indexing=.not.global_indexing	                          local_indexing=.not.global_indexing

      call create_dyn_horgrid(dG, fHI) !, bathymetry_at_vel=b	      call create_dyn_horgrid(dG, fHI) !, bathymetry_at_vel=b
      call clone_MOM_domain(fGD, dG%Domain)			      call clone_MOM_domain(fGD, dG%Domain)

      ! Set the bathymetry, Coriolis parameter, open channel 	      ! Set the bathymetry, Coriolis parameter, open channel 
      call SIS_initialize_fixed(dG, US, param_file, .false., 	      call SIS_initialize_fixed(dG, US, param_file, .false., 

      call set_hor_grid(Ice%fCS%G, param_file, global_indexin	      call set_hor_grid(Ice%fCS%G, param_file, global_indexin
      call copy_dyngrid_to_SIS_horgrid(dG, Ice%fCS%G)		      call copy_dyngrid_to_SIS_horgrid(dG, Ice%fCS%G)
      call destroy_dyn_horgrid(dG)				      call destroy_dyn_horgrid(dG)
      Ice%fCS%G%US => US					      Ice%fCS%G%US => US
      Ice%OBC => OBC_in						      Ice%OBC => OBC_in
    endif							    endif

    Ice%fCS%bounds_check = bounds_check				    Ice%fCS%bounds_check = bounds_check
    Ice%fCS%debug = debug_fast					    Ice%fCS%debug = debug_fast
    Ice%fCS%Eulerian_tsurf = Eulerian_tsurf			    Ice%fCS%Eulerian_tsurf = Eulerian_tsurf
    Ice%fCS%redo_fast_update = redo_fast_update			    Ice%fCS%redo_fast_update = redo_fast_update

    ! Set up the ice-specific grid describing categories and 	    ! Set up the ice-specific grid describing categories and 
    call set_ice_grid(Ice%fCS%IG, US, param_file, nCat_dflt, 	    call set_ice_grid(Ice%fCS%IG, US, param_file, nCat_dflt, 
    if (slab_ice) Ice%fCS%IG%CatIce = 1 ! open water and ice 	    if (slab_ice) Ice%fCS%IG%CatIce = 1 ! open water and ice 
    CatIce = Ice%fCS%IG%CatIce ; NkIce = Ice%fCS%IG%NkIce	    CatIce = Ice%fCS%IG%CatIce ; NkIce = Ice%fCS%IG%NkIce

    call initialize_ice_categories(Ice%fCS%IG, Rho_ice, US, p	    call initialize_ice_categories(Ice%fCS%IG, Rho_ice, US, p

  ! Allocate and register fields for restarts.			  ! Allocate and register fields for restarts.

    if (.not.slow_ice_PE) call set_domain(fGD%mpp_domain)	    if (.not.slow_ice_PE) call set_domain(fGD%mpp_domain)
      ! if this is just a fast ice PE then read restart filen |	    ! if this is just a fast ice PE then read restart filenam
      if (.not.associated(Ice%Ice_restart)) &		      |	    if (.not.associated(Ice%Ice_restart)) &
          call SIS_restart_init(Ice%Ice_restart, restart_file |	        call SIS_restart_init(Ice%Ice_restart, restart_file, 
							      |
      if (split_restart_files) then			      |	    if (split_restart_files) then
        if (.not.associated(Ice%Ice_fast_restart)) &	      |	      if (.not.associated(Ice%Ice_fast_restart)) &
          call SIS_restart_init(Ice%Ice_fast_restart, fast_re |	        call SIS_restart_init(Ice%Ice_fast_restart, fast_rest
      else						      |	    else
        Ice%Ice_fast_restart => Ice%Ice_restart		      |	      Ice%Ice_fast_restart => Ice%Ice_restart
    endif							    endif

  ! These allocation routines are called on all PEs; whether 	  ! These allocation routines are called on all PEs; whether 
  ! they allocate are registered for inclusion in restart fil	  ! they allocate are registered for inclusion in restart fil
  ! whether the Ice%Ice...restart types are associated.		  ! whether the Ice%Ice...restart types are associated.
    call ice_type_fast_reg_restarts(fGD%mpp_domain, CatIce, &	    call ice_type_fast_reg_restarts(fGD%mpp_domain, CatIce, &
                      param_file, Ice, Ice%Ice_fast_restart)	                      param_file, Ice, Ice%Ice_fast_restart)
    if (split_restart_files) &					    if (split_restart_files) &
      call register_unit_conversion_restarts(Ice%fCS%US, Ice%	      call register_unit_conversion_restarts(Ice%fCS%US, Ice%

    if (redo_fast_update .or. .not.single_IST) then		    if (redo_fast_update .or. .not.single_IST) then
      call alloc_IST_arrays(fHI, Ice%fCS%IG, US, Ice%fCS%IST,	      call alloc_IST_arrays(fHI, Ice%fCS%IG, US, Ice%fCS%IST,
                            omit_velocities=.true., omit_tsur	                            omit_velocities=.true., omit_tsur
    endif							    endif
    if (.not.single_IST) then					    if (.not.single_IST) then
      call alloc_fast_ice_avg(Ice%fCS%FIA, fHI, Ice%fCS%IG, i	      call alloc_fast_ice_avg(Ice%fCS%FIA, fHI, Ice%fCS%IG, i

      call alloc_simple_OSS(Ice%fCS%sOSS, fHI, gas_fields_ocn	      call alloc_simple_OSS(Ice%fCS%sOSS, fHI, gas_fields_ocn
    endif							    endif
    call alloc_total_sfc_flux(Ice%fCS%TSF, fHI, gas_fluxes)	    call alloc_total_sfc_flux(Ice%fCS%TSF, fHI, gas_fluxes)
    Ice%fCS%FIA%atmos_winds = atmos_winds			    Ice%fCS%FIA%atmos_winds = atmos_winds

    call ice_rad_register_restarts(fHI, Ice%fCS%IG, US, param	    call ice_rad_register_restarts(fHI, Ice%fCS%IG, US, param
    Ice%fCS%Rad%do_sun_angle_for_alb = do_sun_angle_for_alb	    Ice%fCS%Rad%do_sun_angle_for_alb = do_sun_angle_for_alb
    Ice%fCS%Rad%add_diurnal_sw = add_diurnal_sw			    Ice%fCS%Rad%add_diurnal_sw = add_diurnal_sw

    if (Concurrent_ice) then					    if (Concurrent_ice) then
      call register_fast_to_slow_restarts(Ice%fCS%FIA, Ice%fC	      call register_fast_to_slow_restarts(Ice%fCS%FIA, Ice%fC
                       fGD%mpp_domain, US, Ice%Ice_fast_resta	                       fGD%mpp_domain, US, Ice%Ice_fast_resta
    endif							    endif

    allocate(Ice%fCS%diag)					    allocate(Ice%fCS%diag)
    call SIS_diag_mediator_init(fG, Ice%fCS%IG, param_file, I	    call SIS_diag_mediator_init(fG, Ice%fCS%IG, param_file, I
                                doc_file_dir = dirs%output_di	                                doc_file_dir = dirs%output_di
    call set_SIS_axes_info(fG, Ice%fCS%IG, param_file, Ice%fC	    call set_SIS_axes_info(fG, Ice%fCS%IG, param_file, Ice%fC

    if (redo_fast_update .or. .not.single_IST) then		    if (redo_fast_update .or. .not.single_IST) then
      call ice_thermo_init(param_file, Ice%fCS%IST%ITV, US, i	      call ice_thermo_init(param_file, Ice%fCS%IST%ITV, US, i
    endif							    endif

    if (.not.single_IST) then					    if (.not.single_IST) then
      ! Set a few final things to complete the setup of the g	      ! Set a few final things to complete the setup of the g
      fG%g_Earth = g_Earth					      fG%g_Earth = g_Earth
      call set_first_direction(fG, first_direction)		      call set_first_direction(fG, first_direction)
      call clone_MOM_domain(fGD, fG%domain_aux, symmetric=.fa	      call clone_MOM_domain(fGD, fG%domain_aux, symmetric=.fa
                            domain_name="ice model aux")	                            domain_name="ice model aux")

    endif							    endif

    ! Copy the ice model's domain into one with no halos that	    ! Copy the ice model's domain into one with no halos that
    ! publicly for use by the exchange grid.			    ! publicly for use by the exchange grid.
    call clone_MOM_domain(Ice%fCS%G%Domain, Ice%domain, halo_	    call clone_MOM_domain(Ice%fCS%G%Domain, Ice%domain, halo_
                          symmetric=.false., domain_name="ice	                          symmetric=.false., domain_name="ice
  endif								  endif


  ! Read the restart file, if it exists and reading it is ind	  ! Read the restart file, if it exists and reading it is ind
  ! and initialize the ice arrays to default values using oth	  ! and initialize the ice arrays to default values using oth
  if (slow_ice_PE) then						  if (slow_ice_PE) then
    ! Set some pointers for convenience.			    ! Set some pointers for convenience.
    sIST => Ice%sCS%IST ; sIG => Ice%sCS%IG ; sG => Ice%sCS%G	    sIST => Ice%sCS%IST ; sIG => Ice%sCS%IG ; sG => Ice%sCS%G

    new_sim = is_new_run(Ice%Ice_restart)			    new_sim = is_new_run(Ice%Ice_restart)
    if (.not.new_sim) then					    if (.not.new_sim) then
      call callTree_enter("ice_model_init():restore_from_rest	      call callTree_enter("ice_model_init():restore_from_rest
      ! Set a value of IG%H_to_kg_m2 that will permit its abs	      ! Set a value of IG%H_to_kg_m2 that will permit its abs
      ! detected, as a way to detect an archaic restart file 	      ! detected, as a way to detect an archaic restart file 
      sIG%H_to_kg_m2 = -1.0					      sIG%H_to_kg_m2 = -1.0
      is_restart = .true.					      is_restart = .true.
      recategorize_ice = .false. ! Assume that the ice is alr	      recategorize_ice = .false. ! Assume that the ice is alr

      call restore_SIS_state(Ice%Ice_restart, dirs%restart_in	      call restore_SIS_state(Ice%Ice_restart, dirs%restart_in

      ! If the velocity and other fields have not been initia	      ! If the velocity and other fields have not been initia
      ! the fields that would have been read if symmetric wer	      ! the fields that would have been read if symmetric wer
      call ice_state_read_alt_restarts(sIST, sG, sIG, US, Ice	      call ice_state_read_alt_restarts(sIST, sG, sIG, US, Ice
      if (.not.specified_ice) &					      if (.not.specified_ice) &
        call SIS_dyn_trans_read_alt_restarts(Ice%sCS%dyn_tran	        call SIS_dyn_trans_read_alt_restarts(Ice%sCS%dyn_tran
                                             dirs%restart_inp	                                             dirs%restart_inp

      call rescale_ice_state_restart_fields(sIST, sG, US, sIG	      call rescale_ice_state_restart_fields(sIST, sG, US, sIG
      sIG%H_to_kg_m2 = 1.0					      sIG%H_to_kg_m2 = 1.0

      if ((.not.query_initialized(Ice%Ice_restart, 'enth_ice'	      if ((.not.query_initialized(Ice%Ice_restart, 'enth_ice'
          (.not.query_initialized(Ice%Ice_restart, 'enth_snow	          (.not.query_initialized(Ice%Ice_restart, 'enth_snow
          (.not.query_initialized(Ice%Ice_restart, 'sal_ice')	          (.not.query_initialized(Ice%Ice_restart, 'sal_ice')
        ! Approximately initialize state fields that are not 	        ! Approximately initialize state fields that are not 
        ! in SIS1 restart files.  This is obsolete and can pr	        ! in SIS1 restart files.  This is obsolete and can pr
        call read_archaic_thermo_restarts(Ice, sIST, sG, sIG,	        call read_archaic_thermo_restarts(Ice, sIST, sG, sIG,
      endif							      endif

      if (Ice%sCS%pass_stress_mag .and. .not.query_initialize	      if (Ice%sCS%pass_stress_mag .and. .not.query_initialize
        ! Determine the magnitude of the stresses from the (n	        ! Determine the magnitude of the stresses from the (n
        ! in the Ice type, which will have been read from the	        ! in the Ice type, which will have been read from the
        allocate(str_x(sG%isd:sG%ied, sG%jsd:sG%jed), source=	        allocate(str_x(sG%isd:sG%ied, sG%jsd:sG%jed), source=
        allocate(str_y(sG%isd:sG%ied, sG%jsd:sG%jed), source=	        allocate(str_y(sG%isd:sG%ied, sG%jsd:sG%jed), source=
        allocate(stress_mag(sG%isd:sG%ied, sG%jsd:sG%jed), so	        allocate(stress_mag(sG%isd:sG%ied, sG%jsd:sG%jed), so

        i_off = LBOUND(Ice%stress_mag,1) - sG%isc ; j_off = L	        i_off = LBOUND(Ice%stress_mag,1) - sG%isc ; j_off = L
        do j=sG%jsc,sG%jec ; do i=sG%isc,sG%iec ; i2 = i+i_of	        do j=sG%jsc,sG%jec ; do i=sG%isc,sG%iec ; i2 = i+i_of
          str_x(i,j) = Ice%flux_u(i2,j2) ; str_y(i,j) = Ice%f	          str_x(i,j) = Ice%flux_u(i2,j2) ; str_y(i,j) = Ice%f
        enddo ; enddo						        enddo ; enddo
        ! This serves to fill in the symmetric-edge stress po	        ! This serves to fill in the symmetric-edge stress po
        if ((Ice%flux_uv_stagger == BGRID_NE) .or. (Ice%flux_	        if ((Ice%flux_uv_stagger == BGRID_NE) .or. (Ice%flux_
          call pass_vector(str_x, str_y, sG%Domain_aux, stagg	          call pass_vector(str_x, str_y, sG%Domain_aux, stagg

        call stresses_to_stress_mag(sG, str_x, str_y, Ice%flu	        call stresses_to_stress_mag(sG, str_x, str_y, Ice%flu

        do j=sG%jsc,sG%jec ; do i=sG%isc,sG%iec ; i2 = i+i_of	        do j=sG%jsc,sG%jec ; do i=sG%isc,sG%iec ; i2 = i+i_of
          Ice%stress_mag(i2,j2) = stress_mag(i,j)		          Ice%stress_mag(i2,j2) = stress_mag(i,j)
        enddo ; enddo						        enddo ; enddo

        deallocate(str_x, str_y, stress_mag)			        deallocate(str_x, str_y, stress_mag)
      endif							      endif

      if (fast_ice_PE .and. .not.split_restart_files) then	      if (fast_ice_PE .and. .not.split_restart_files) then
        init_coszen = .not.query_initialized(Ice%Ice_fast_res	        init_coszen = .not.query_initialized(Ice%Ice_fast_res
        init_Tskin  = .not.query_initialized(Ice%Ice_fast_res	        init_Tskin  = .not.query_initialized(Ice%Ice_fast_res
        init_rough  = .not.(query_initialized(Ice%Ice_fast_re	        init_rough  = .not.(query_initialized(Ice%Ice_fast_re
                            query_initialized(Ice%Ice_fast_re	                            query_initialized(Ice%Ice_fast_re
                            query_initialized(Ice%Ice_fast_re	                            query_initialized(Ice%Ice_fast_re
      endif							      endif

      call callTree_leave("ice_model_init():restore_from_rest	      call callTree_leave("ice_model_init():restore_from_rest
    endif ! End of (.not.new_sim)				    endif ! End of (.not.new_sim)

    ! If there is not a restart file, initialize the ice anot	    ! If there is not a restart file, initialize the ice anot
    ! If there is a restart file, the following two calls are	    ! If there is a restart file, the following two calls are
    call ice_state_mass_init(sIST, Ice, sG, sIG, US, param_fi	    call ice_state_mass_init(sIST, Ice, sG, sIG, US, param_fi

    call ice_state_thermo_init(sIST, Ice, sG, sIG, US, param_	    call ice_state_thermo_init(sIST, Ice, sG, sIG, US, param_
                               just_read_params=is_restart)	                               just_read_params=is_restart)

    if (.not.is_restart) then					    if (.not.is_restart) then
      ! Record the need to transfer ice to the correct thickn	      ! Record the need to transfer ice to the correct thickn
      recategorize_ice = .true.					      recategorize_ice = .true.
      init_coszen = .true. ; init_Tskin = .true. ; init_rough	      init_coszen = .true. ; init_Tskin = .true. ; init_rough
    endif							    endif

    ! The restart files have now been read or the variables t	    ! The restart files have now been read or the variables t
    ! files have been initialized, although some corrections 	    ! files have been initialized, although some corrections 
    ! Now call the initialization routines for any dependent 	    ! Now call the initialization routines for any dependent 

    call ice_diagnostics_init(Ice%sCS%IOF, Ice%sCS%OSS, Ice%s	    call ice_diagnostics_init(Ice%sCS%IOF, Ice%sCS%OSS, Ice%s
                              Ice%sCS%diag, Ice%sCS%Time, Cgr	                              Ice%sCS%diag, Ice%sCS%Time, Cgr
    Ice%axes(1:3) = Ice%sCS%diag%axesTc0%handles(1:3)		    Ice%axes(1:3) = Ice%sCS%diag%axesTc0%handles(1:3)

    Ice%sCS%Time_step_slow = Time_step_slow			    Ice%sCS%Time_step_slow = Time_step_slow

    call SIS_slow_thermo_init(Ice%sCS%Time, sG, US, sIG, para	    call SIS_slow_thermo_init(Ice%sCS%Time, sG, US, sIG, para
                              Ice%sCS%slow_thermo_CSp, Ice%sC	                              Ice%sCS%slow_thermo_CSp, Ice%sC

    if (specified_ice) then					    if (specified_ice) then
      recategorize_ice = .false.				      recategorize_ice = .false.
      call specified_ice_init(Ice%sCS%Time, sG, sIG, param_fi	      call specified_ice_init(Ice%sCS%Time, sG, sIG, param_fi
                              Ice%sCS%specified_ice_CSp, dirs	                              Ice%sCS%specified_ice_CSp, dirs
      call SIS_slow_thermo_set_ptrs(Ice%sCS%slow_thermo_CSp, 	      call SIS_slow_thermo_set_ptrs(Ice%sCS%slow_thermo_CSp, 
                   sum_out_CSp=specified_ice_sum_output_CS(Ic	                   sum_out_CSp=specified_ice_sum_output_CS(Ic

      ! When SPECIFIED_ICE=True, the variable Ice%sCS%OSS%SST	      ! When SPECIFIED_ICE=True, the variable Ice%sCS%OSS%SST
      ! and needs to be updated for each run segment, regardl	      ! and needs to be updated for each run segment, regardl
      call get_sea_surface(Ice%sCS%Time, sG%HI, SST=Ice%sCS%O	      call get_sea_surface(Ice%sCS%Time, sG%HI, SST=Ice%sCS%O
      if (.not.is_restart) then					      if (.not.is_restart) then
        ! Perhaps ice_conc and h_ice_input should also be rea	        ! Perhaps ice_conc and h_ice_input should also be rea
        allocate(h_ice_input(sG%isd:sG%ied, sG%jsd:sG%jed), s	        allocate(h_ice_input(sG%isd:sG%ied, sG%jsd:sG%jed), s
        call get_sea_surface(Ice%sCS%Time, sG%HI, SST=Ice%sCS	        call get_sea_surface(Ice%sCS%Time, sG%HI, SST=Ice%sCS
                             ice_thick=h_ice_input, ice_domai	                             ice_thick=h_ice_input, ice_domai
        do j=jsc,jec ; do i=isc,iec				        do j=jsc,jec ; do i=isc,iec
          sIST%part_size(i,j,0) = 1.0 - sIST%part_size(i,j,1)	          sIST%part_size(i,j,0) = 1.0 - sIST%part_size(i,j,1)
          sIST%mH_ice(i,j,1) = h_ice_input(i,j)*US%m_to_Z * R	          sIST%mH_ice(i,j,1) = h_ice_input(i,j)*US%m_to_Z * R
        enddo ; enddo						        enddo ; enddo
        deallocate(h_ice_input)					        deallocate(h_ice_input)
      endif							      endif
    else							    else
      call SIS_dyn_trans_init(Ice%sCS%Time, sG, US, sIG, para	      call SIS_dyn_trans_init(Ice%sCS%Time, sG, US, sIG, para
                              Ice%sCS%dyn_trans_CSp, dirs%out	                              Ice%sCS%dyn_trans_CSp, dirs%out
                              slab_ice=slab_ice)		                              slab_ice=slab_ice)
      call SIS_slow_thermo_set_ptrs(Ice%sCS%slow_thermo_CSp, 	      call SIS_slow_thermo_set_ptrs(Ice%sCS%slow_thermo_CSp, 
                   transport_CSp=SIS_dyn_trans_transport_CS(I	                   transport_CSp=SIS_dyn_trans_transport_CS(I
                   sum_out_CSp=SIS_dyn_trans_sum_output_CS(Ic	                   sum_out_CSp=SIS_dyn_trans_sum_output_CS(Ic
    endif							    endif


    ! Apply corrections to the ice state, like readjusting ic	    ! Apply corrections to the ice state, like readjusting ic
    ! These corrections occur here so that they can use adjus	    ! These corrections occur here so that they can use adjus

    if (do_mask_restart) then					    if (do_mask_restart) then
      ! Deal with any ice masses, thicknesses and other prope	      ! Deal with any ice masses, thicknesses and other prope
      if (allocated(sIST%t_surf)) then ; do j=jsc,jec ; do i=	      if (allocated(sIST%t_surf)) then ; do j=jsc,jec ; do i=
        if (sG%mask2dT(i,j) < 0.5) sIST%t_surf(i,j,:) = sIST%	        if (sG%mask2dT(i,j) < 0.5) sIST%t_surf(i,j,:) = sIST%
      enddo ; enddo ; endif					      enddo ; enddo ; endif
      do n=1,NkIce ; do k=1,CatIce ; do j=jsc,jec ; do i=isc,	      do n=1,NkIce ; do k=1,CatIce ; do j=jsc,jec ; do i=isc,
        sIST%sal_ice(i,j,k,n) = sIST%sal_ice(i,j,k,n) * sG%ma	        sIST%sal_ice(i,j,k,n) = sIST%sal_ice(i,j,k,n) * sG%ma
        sIST%enth_ice(i,j,k,n) = sIST%enth_ice(i,j,k,n) * sG%	        sIST%enth_ice(i,j,k,n) = sIST%enth_ice(i,j,k,n) * sG%
      enddo ; enddo ; enddo ; enddo				      enddo ; enddo ; enddo ; enddo
      do k=1,CatIce ; do j=jsc,jec ; do i=isc,iec		      do k=1,CatIce ; do j=jsc,jec ; do i=isc,iec
        sIST%mH_snow(i,j,k) = sIST%mH_snow(i,j,k) * sG%mask2d	        sIST%mH_snow(i,j,k) = sIST%mH_snow(i,j,k) * sG%mask2d
        sIST%enth_snow(i,j,k,1) = sIST%enth_snow(i,j,k,1) * s	        sIST%enth_snow(i,j,k,1) = sIST%enth_snow(i,j,k,1) * s
        sIST%mH_ice(i,j,k) = sIST%mH_ice(i,j,k) * sG%mask2dT(	        sIST%mH_ice(i,j,k) = sIST%mH_ice(i,j,k) * sG%mask2dT(
        sIST%mH_pond(i,j,k) = sIST%mH_pond(i,j,k) * sG%mask2d	        sIST%mH_pond(i,j,k) = sIST%mH_pond(i,j,k) * sG%mask2d
        sIST%part_size(i,j,k) = sIST%part_size(i,j,k) * sG%ma	        sIST%part_size(i,j,k) = sIST%part_size(i,j,k) * sG%ma
      enddo ; enddo ; enddo					      enddo ; enddo ; enddo
      ! Since we masked out the part_size on land we should s	      ! Since we masked out the part_size on land we should s
      ! part_size(i,j,0) = 1. on land to satisfy the summatio	      ! part_size(i,j,0) = 1. on land to satisfy the summatio
      do j=jsc,jec ; do i=isc,iec				      do j=jsc,jec ; do i=isc,iec
        if (sG%mask2dT(i,j) < 0.5) sIST%part_size(i,j,0) = 1.	        if (sG%mask2dT(i,j) < 0.5) sIST%part_size(i,j,0) = 1.
      enddo ; enddo						      enddo ; enddo
    endif							    endif

    if (recategorize_ice) then					    if (recategorize_ice) then
      ! Transfer ice to the correct thickness categories.  Th	      ! Transfer ice to the correct thickness categories.  Th
      ! other properties where the ice is already in the corr	      ! other properties where the ice is already in the corr
      call adjust_ice_categories(sIST%mH_ice, sIST%mH_snow, s	      call adjust_ice_categories(sIST%mH_ice, sIST%mH_snow, s
                            sIST%TrReg, sG, sIG, SIS_dyn_tran	                            sIST%TrReg, sG, sIG, SIS_dyn_tran
    endif							    endif

    if (sIG%ocean_part_min > 0.0) then ; do j=jsc,jec ; do i=	    if (sIG%ocean_part_min > 0.0) then ; do j=jsc,jec ; do i=
      sIST%part_size(i,j,0) = max(sIST%part_size(i,j,0), sIG%	      sIST%part_size(i,j,0) = max(sIST%part_size(i,j,0), sIG%
    enddo ; enddo ; endif					    enddo ; enddo ; endif

    !--- update the halo values for the physical ice state.	    !--- update the halo values for the physical ice state.
    call pass_var(sIST%part_size, sGD, complete=.true.)		    call pass_var(sIST%part_size, sGD, complete=.true.)
    call pass_var(sIST%mH_ice, sGD, complete=.false.)		    call pass_var(sIST%mH_ice, sGD, complete=.false.)
    call pass_var(sIST%mH_snow, sGD, complete=.false.)		    call pass_var(sIST%mH_snow, sGD, complete=.false.)
    call pass_var(sIST%mH_pond, sGD, complete=.false.)		    call pass_var(sIST%mH_pond, sGD, complete=.false.)
    do l=1,NkIce						    do l=1,NkIce
      call pass_var(sIST%enth_ice(:,:,:,l), sGD, complete=.fa	      call pass_var(sIST%enth_ice(:,:,:,l), sGD, complete=.fa
    enddo							    enddo
    call pass_var(sIST%enth_snow(:,:,:,1), sGD, complete=.tru	    call pass_var(sIST%enth_snow(:,:,:,1), sGD, complete=.tru
    if (Cgrid_dyn) then						    if (Cgrid_dyn) then
      call pass_vector(sIST%u_ice_C, sIST%v_ice_C, sGD, stagg	      call pass_vector(sIST%u_ice_C, sIST%v_ice_C, sGD, stagg
    else							    else
      call pass_vector(sIST%u_ice_B, sIST%v_ice_B, sGD, stagg	      call pass_vector(sIST%u_ice_B, sIST%v_ice_B, sGD, stagg
    endif							    endif

    ! The slow physical ice properties do not change after th	    ! The slow physical ice properties do not change after th

    if (Ice%sCS%redo_fast_update) then				    if (Ice%sCS%redo_fast_update) then
      call SIS_fast_thermo_init(Ice%sCS%Time, sG, sIG, param_	      call SIS_fast_thermo_init(Ice%sCS%Time, sG, sIG, param_
                                Ice%sCS%fast_thermo_CSp)	                                Ice%sCS%fast_thermo_CSp)
      call SIS_optics_init(param_file, US, Ice%sCS%optics_CSp	      call SIS_optics_init(param_file, US, Ice%sCS%optics_CSp
    endif							    endif

  !   Initialize any tracers that will be handled via tracer 	  !   Initialize any tracers that will be handled via tracer 
    call SIS_tracer_flow_control_init(Ice%sCS%Time, sG, sIG, 	    call SIS_tracer_flow_control_init(Ice%sCS%Time, sG, sIG, 
                                      Ice%sCS%SIS_tracer_flow	                                      Ice%sCS%SIS_tracer_flow

  ! Initialize icebergs						  ! Initialize icebergs
    if (Ice%sCS%do_icebergs) then				    if (Ice%sCS%do_icebergs) then
      call get_param(param_file, mdl, "ICEBERG_WINDSTRESS_BUG	      call get_param(param_file, mdl, "ICEBERG_WINDSTRESS_BUG
                 "If true, use older code that applied an old	                 "If true, use older code that applied an old
                 "stress to the icebergs in place of the curr	                 "stress to the icebergs in place of the curr
                 "stress.  This option is here for backward c	                 "stress.  This option is here for backward c
                 "but should be avoided.", default=.false.)	                 "but should be avoided.", default=.false.)

      isc = sG%isc ; iec = sG%iec ; jsc = sG%jsc ; jec = sG%j	      isc = sG%isc ; iec = sG%iec ; jsc = sG%jsc ; jec = sG%j

      if (ASSOCIATED(sGD%maskmap)) then				      if (ASSOCIATED(sGD%maskmap)) then
        call icebergs_init(Ice%icebergs, sGD%niglobal, sGD%nj	        call icebergs_init(Ice%icebergs, sGD%niglobal, sGD%nj
                sGD%layout, sGD%io_layout, Ice%axes(1:2), &	                sGD%layout, sGD%io_layout, Ice%axes(1:2), &
                sGD%X_flags, sGD%Y_flags, time_type_to_real(T	                sGD%X_flags, sGD%Y_flags, time_type_to_real(T
                Time, sG%geoLonBu(isc:iec,jsc:jec), sG%geoLat	                Time, sG%geoLonBu(isc:iec,jsc:jec), sG%geoLat
                sG%mask2dT(isc-1:iec+1,jsc-1:jec+1), &		                sG%mask2dT(isc-1:iec+1,jsc-1:jec+1), &
                US%L_to_m*sG%dxCv(isc-1:iec+1,jsc-1:jec+1), U	                US%L_to_m*sG%dxCv(isc-1:iec+1,jsc-1:jec+1), U
                Ice%area,  sG%cos_rot(isc-1:iec+1,jsc-1:jec+1	                Ice%area,  sG%cos_rot(isc-1:iec+1,jsc-1:jec+1
                sG%sin_rot(isc-1:iec+1,jsc-1:jec+1), maskmap=	                sG%sin_rot(isc-1:iec+1,jsc-1:jec+1), maskmap=
      else							      else
        call icebergs_init(Ice%icebergs, sGD%niglobal, sGD%nj	        call icebergs_init(Ice%icebergs, sGD%niglobal, sGD%nj
                 sGD%layout, sGD%io_layout, Ice%axes(1:2), &	                 sGD%layout, sGD%io_layout, Ice%axes(1:2), &
                 sGD%X_flags, sGD%Y_flags, time_type_to_real(	                 sGD%X_flags, sGD%Y_flags, time_type_to_real(
                 Time, sG%geoLonBu(isc:iec,jsc:jec), sG%geoLa	                 Time, sG%geoLonBu(isc:iec,jsc:jec), sG%geoLa
                 sG%mask2dT(isc-1:iec+1,jsc-1:jec+1), &		                 sG%mask2dT(isc-1:iec+1,jsc-1:jec+1), &
                 US%L_to_m*sG%dxCv(isc-1:iec+1,jsc-1:jec+1), 	                 US%L_to_m*sG%dxCv(isc-1:iec+1,jsc-1:jec+1), 
                 Ice%area, sG%cos_rot(isc-1:iec+1,jsc-1:jec+1	                 Ice%area, sG%cos_rot(isc-1:iec+1,jsc-1:jec+1
                 sG%sin_rot(isc-1:iec+1,jsc-1:jec+1) )		                 sG%sin_rot(isc-1:iec+1,jsc-1:jec+1) )
      endif							      endif
    endif							    endif

    ! Do any error checking here.				    ! Do any error checking here.
    if (Ice%sCS%debug) call ice_grid_chksum(sG, US, haloshift	    if (Ice%sCS%debug) call ice_grid_chksum(sG, US, haloshift

    if (specified_ice) then					    if (specified_ice) then
      call write_ice_statistics(sIST, Ice%sCS%Time, 0, sG, US	      call write_ice_statistics(sIST, Ice%sCS%Time, 0, sG, US
               specified_ice_sum_output_CS(Ice%sCS%specified_	               specified_ice_sum_output_CS(Ice%sCS%specified_
    else							    else
      call write_ice_statistics(sIST, Ice%sCS%Time, 0, sG, US	      call write_ice_statistics(sIST, Ice%sCS%Time, 0, sG, US
               SIS_dyn_trans_sum_output_CS(Ice%sCS%dyn_trans_	               SIS_dyn_trans_sum_output_CS(Ice%sCS%dyn_trans_
    endif							    endif
  endif  ! slow_ice_PE						  endif  ! slow_ice_PE


  if (fast_ice_PE) then						  if (fast_ice_PE) then
    ! Read the fast_restart file and initialize the subsidiar	    ! Read the fast_restart file and initialize the subsidiar
    ! fast ice processes.					    ! fast ice processes.

    ! Set some pointers for convenience.			    ! Set some pointers for convenience.
    fG => Ice%fCS%G ; fGD => Ice%fCS%G%Domain			    fG => Ice%fCS%G ; fGD => Ice%fCS%G%Domain

    if ((.not.slow_ice_PE) .or. split_restart_files) then	    if ((.not.slow_ice_PE) .or. split_restart_files) then
      ! Read the fast restart file, if it exists and this is 	      ! Read the fast restart file, if it exists and this is 
      new_sim = determine_is_new_run(dirs%input_filename, dir	      new_sim = determine_is_new_run(dirs%input_filename, dir
      if (.not.new_sim) then					      if (.not.new_sim) then
        call restore_SIS_state(Ice%Ice_fast_restart, dirs%res	        call restore_SIS_state(Ice%Ice_fast_restart, dirs%res
        init_coszen = .not.query_initialized(Ice%Ice_fast_res	        init_coszen = .not.query_initialized(Ice%Ice_fast_res
        init_Tskin  = .not.query_initialized(Ice%Ice_fast_res	        init_Tskin  = .not.query_initialized(Ice%Ice_fast_res
        init_rough  = .not.(query_initialized(Ice%Ice_fast_re	        init_rough  = .not.(query_initialized(Ice%Ice_fast_re
                            query_initialized(Ice%Ice_fast_re	                            query_initialized(Ice%Ice_fast_re
                            query_initialized(Ice%Ice_fast_re	                            query_initialized(Ice%Ice_fast_re
      else							      else
        init_coszen = .true. ; init_Tskin = .true. ; init_rou	        init_coszen = .true. ; init_Tskin = .true. ; init_rou
      endif							      endif
    endif							    endif

    if (Concurrent_ice) then					    if (Concurrent_ice) then
      call rescale_fast_to_slow_restart_fields(Ice%fCS%FIA, I	      call rescale_fast_to_slow_restart_fields(Ice%fCS%FIA, I
                                               Ice%fCS%G, US,	                                               Ice%fCS%G, US,
    endif							    endif


!  if (Ice%fCS%Rad%add_diurnal_sw .or. Ice%fCS%Rad%do_sun_ang	!  if (Ice%fCS%Rad%add_diurnal_sw .or. Ice%fCS%Rad%do_sun_ang
!    call set_domain(fGD%mpp_domain)				!    call set_domain(fGD%mpp_domain)
    call astronomy_init()					    call astronomy_init()
!    call nullify_domain()					!    call nullify_domain()
!  endif							!  endif

    if (init_coszen) then					    if (init_coszen) then
      if (coszen_IC >= 0.0) then				      if (coszen_IC >= 0.0) then
        Ice%fCS%Rad%coszen_nextrad(:,:) = coszen_IC		        Ice%fCS%Rad%coszen_nextrad(:,:) = coszen_IC
      else							      else
        rad = acos(-1.)/180.					        rad = acos(-1.)/180.
        allocate(dummy(fG%isd:fG%ied,fG%jsd:fG%jed))		        allocate(dummy(fG%isd:fG%ied,fG%jsd:fG%jed))
        call diurnal_solar(fG%geoLatT(:,:)*rad, fG%geoLonT(:,	        call diurnal_solar(fG%geoLatT(:,:)*rad, fG%geoLonT(:,
                           Ice%fCS%Time, cosz=Ice%fCS%Rad%cos	                           Ice%fCS%Time, cosz=Ice%fCS%Rad%cos
                           rrsun=rrsun, dt_time=dT_rad)		                           rrsun=rrsun, dt_time=dT_rad)
        deallocate(dummy)					        deallocate(dummy)
      endif							      endif
    endif							    endif
    if (init_Tskin) then					    if (init_Tskin) then
      Ice%fCS%Rad%t_skin(:,:,:) = 0.0				      Ice%fCS%Rad%t_skin(:,:,:) = 0.0
    elseif (do_mask_restart) then				    elseif (do_mask_restart) then
      do k=1,CatIce						      do k=1,CatIce
        Ice%fCS%Rad%t_skin(:,:,k) = Ice%fCS%Rad%t_skin(:,:,k)	        Ice%fCS%Rad%t_skin(:,:,k) = Ice%fCS%Rad%t_skin(:,:,k)
      enddo							      enddo
    endif							    endif
    if (init_rough) then					    if (init_rough) then
      Ice%rough_mom(:,:,:)   = mom_rough_ice			      Ice%rough_mom(:,:,:)   = mom_rough_ice
      Ice%rough_heat(:,:,:)  = heat_rough_ice			      Ice%rough_heat(:,:,:)  = heat_rough_ice
      Ice%rough_moist(:,:,:) = heat_rough_ice			      Ice%rough_moist(:,:,:) = heat_rough_ice
    endif							    endif

    call ice_diags_fast_init(Ice%fCS%Rad, fG, Ice%fCS%IG, Ice	    call ice_diags_fast_init(Ice%fCS%Rad, fG, Ice%fCS%IG, Ice
                             Ice%fCS%Time, component="ice_mod	                             Ice%fCS%Time, component="ice_mod

    call SIS_fast_thermo_init(Ice%fCS%Time, fG, Ice%fCS%IG, p	    call SIS_fast_thermo_init(Ice%fCS%Time, fG, Ice%fCS%IG, p
                              Ice%fCS%fast_thermo_CSp)		                              Ice%fCS%fast_thermo_CSp)
    call SIS_optics_init(param_file, US, Ice%fCS%optics_CSp, 	    call SIS_optics_init(param_file, US, Ice%fCS%optics_CSp, 

    Ice%fCS%Time_step_fast = Time_step_fast			    Ice%fCS%Time_step_fast = Time_step_fast
    Ice%fCS%Time_step_slow = Time_step_slow			    Ice%fCS%Time_step_slow = Time_step_slow

    isc = fHI%isc ; iec = fHI%iec ; jsc = fHI%jsc ; jec = fHI	    isc = fHI%isc ; iec = fHI%iec ; jsc = fHI%jsc ; jec = fHI
    i_off = LBOUND(Ice%ocean_pt,1) - fHI%isc ; j_off = LBOUND	    i_off = LBOUND(Ice%ocean_pt,1) - fHI%isc ; j_off = LBOUND
    do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off	    do j=jsc,jec ; do i=isc,iec ; i2 = i+i_off ; j2 = j+j_off
      Ice%ocean_pt(i2,j2) = ( fG%mask2dT(i,j) > 0.0 )		      Ice%ocean_pt(i2,j2) = ( fG%mask2dT(i,j) > 0.0 )
    enddo ; enddo						    enddo ; enddo
    if (.not.slow_ice_PE) then					    if (.not.slow_ice_PE) then
      Ice%axes(1:3) = Ice%fCS%diag%axesTc0%handles(1:3)		      Ice%axes(1:3) = Ice%fCS%diag%axesTc0%handles(1:3)
    endif							    endif
  endif ! fast_ice_PE						  endif ! fast_ice_PE
							      |	   
  call fix_restart_unit_scaling(US, unscaled=.true.)		  call fix_restart_unit_scaling(US, unscaled=.true.)

  !nullify_domain perhaps could be called somewhere closer to	  !nullify_domain perhaps could be called somewhere closer to
  !but it should be called after restore_SIS_state() otherwis	  !but it should be called after restore_SIS_state() otherwis
  call nullify_domain()						  call nullify_domain()

  ! Close the parameter file, supplying information for loggi	  ! Close the parameter file, supplying information for loggi
  if (slow_ice_PE) then						  if (slow_ice_PE) then
    call close_param_file(param_file, component='SIS')		    call close_param_file(param_file, component='SIS')
  else								  else
    call close_param_file(param_file, component='SIS_fast')	    call close_param_file(param_file, component='SIS_fast')
  endif								  endif

  ! Ice%xtype can be REDIST or DIRECT, depending on the relat	  ! Ice%xtype can be REDIST or DIRECT, depending on the relat
  ! the fast and slow ice PEs.  REDIST should always work but	  ! the fast and slow ice PEs.  REDIST should always work but
  if (fast_ice_PE .neqv. slow_ice_PE) then			  if (fast_ice_PE .neqv. slow_ice_PE) then
    Ice%xtype = REDIST						    Ice%xtype = REDIST
  elseif (single_IST .or. ((fGD%layout(1) == sGD%layout(1)) .	  elseif (single_IST .or. ((fGD%layout(1) == sGD%layout(1)) .
                           (fGD%layout(2) == sGD%layout(2))) 	                           (fGD%layout(2) == sGD%layout(2))) 
    Ice%xtype = DIRECT						    Ice%xtype = DIRECT
  else								  else
    Ice%xtype = REDIST						    Ice%xtype = REDIST
  endif								  endif
							      >	  
							      >	  if (fast_ice_PE .eqv. slow_ice_PE) then
							      >	    call exchange_fast_to_slow_ice(Ice)
							      >	  endif 

  if (Ice%shared_slow_fast_PEs) then				  if (Ice%shared_slow_fast_PEs) then
    iceClock = cpu_clock_id( 'Ice', grain=CLOCK_COMPONENT )	    iceClock = cpu_clock_id( 'Ice', grain=CLOCK_COMPONENT )
    ice_clock_fast = cpu_clock_id('Ice Fast', grain=CLOCK_SUB	    ice_clock_fast = cpu_clock_id('Ice Fast', grain=CLOCK_SUB
    ice_clock_slow = cpu_clock_id('Ice Slow', grain=CLOCK_SUB	    ice_clock_slow = cpu_clock_id('Ice Slow', grain=CLOCK_SUB
  else								  else
    iceClock = 0 ! The comprehensive ice clock can not be use	    iceClock = 0 ! The comprehensive ice clock can not be use
    if (fast_ice_PE) then					    if (fast_ice_PE) then
      ice_clock_fast = cpu_clock_id('Ice Fast', grain=CLOCK_C	      ice_clock_fast = cpu_clock_id('Ice Fast', grain=CLOCK_C
    elseif (slow_ice_PE) then					    elseif (slow_ice_PE) then
      ice_clock_slow = cpu_clock_id('Ice Slow', grain=CLOCK_C	      ice_clock_slow = cpu_clock_id('Ice Slow', grain=CLOCK_C
    endif							    endif
  endif								  endif

  call callTree_leave("ice_model_init()")			  call callTree_leave("ice_model_init()")

end subroutine ice_model_init					end subroutine ice_model_init

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> share_ice_domains exchanges domain information between the	!> share_ice_domains exchanges domain information between the
subroutine share_ice_domains(Ice)				subroutine share_ice_domains(Ice)
  type(ice_data_type), intent(inout) :: Ice !< The publicly v	  type(ice_data_type), intent(inout) :: Ice !< The publicly v

  ! This code has to be called for all of the ice processors 	  ! This code has to be called for all of the ice processors 
  ! union of the fast and slow ice PE_lists.			  ! union of the fast and slow ice PE_lists.

  if (associated(Ice%sCS)) then					  if (associated(Ice%sCS)) then
    Ice%slow_domain => Ice%sCS%G%domain%mpp_domain		    Ice%slow_domain => Ice%sCS%G%domain%mpp_domain
  else								  else
    allocate(Ice%slow_domain)					    allocate(Ice%slow_domain)
  endif								  endif
  if (associated(Ice%fCS)) then					  if (associated(Ice%fCS)) then
    Ice%fast_domain => Ice%fCS%G%domain%mpp_domain		    Ice%fast_domain => Ice%fCS%G%domain%mpp_domain
  else								  else
    allocate(Ice%fast_domain)					    allocate(Ice%fast_domain)
  endif								  endif
  call broadcast_domain(Ice%Domain)				  call broadcast_domain(Ice%Domain)
  call broadcast_domain(Ice%slow_domain_NH)			  call broadcast_domain(Ice%slow_domain_NH)
  call broadcast_domain(Ice%slow_domain)			  call broadcast_domain(Ice%slow_domain)
  call broadcast_domain(Ice%fast_domain)			  call broadcast_domain(Ice%fast_domain)

  if (Ice%shared_slow_fast_PEs) then				  if (Ice%shared_slow_fast_PEs) then
    ice_clock_exchange = cpu_clock_id('Ice Fast/Slow Exchange	    ice_clock_exchange = cpu_clock_id('Ice Fast/Slow Exchange
  else								  else
    ice_clock_exchange = cpu_clock_id('Ice Fast/Slow Exchange	    ice_clock_exchange = cpu_clock_id('Ice Fast/Slow Exchange
  endif								  endif

end subroutine share_ice_domains				end subroutine share_ice_domains


!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> update_ice_atm_deposition_flux updates the values of any f	!> update_ice_atm_deposition_flux updates the values of any f
!! labeled as having the type 'air_sea_deposition'.  With the	!! labeled as having the type 'air_sea_deposition'.  With the
!! these fluxes were not available when update_ice_model_fast	!! these fluxes were not available when update_ice_model_fast
subroutine update_ice_atm_deposition_flux( Atmos_boundary, Ic	subroutine update_ice_atm_deposition_flux( Atmos_boundary, Ic
  type(ice_data_type),           intent(inout) :: Ice !< The 	  type(ice_data_type),           intent(inout) :: Ice !< The 
  type(atmos_ice_boundary_type), intent(inout) :: Atmos_bound	  type(atmos_ice_boundary_type), intent(inout) :: Atmos_bound
                                                      !! forc	                                                      !! forc

  call accumulate_deposition_fluxes(Atmos_boundary, Ice%fCS%F	  call accumulate_deposition_fluxes(Atmos_boundary, Ice%fCS%F

end subroutine update_ice_atm_deposition_flux			end subroutine update_ice_atm_deposition_flux


!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!> ice_model_end writes the restart file and deallocates memo	!> ice_model_end writes the restart file and deallocates memo
subroutine ice_model_end(Ice)					subroutine ice_model_end(Ice)
  type(ice_data_type), intent(inout) :: Ice !< The publicly v	  type(ice_data_type), intent(inout) :: Ice !< The publicly v

  logical :: fast_ice_PE       ! If true, fast ice processes 	  logical :: fast_ice_PE       ! If true, fast ice processes 
  logical :: slow_ice_PE       ! If true, slow ice processes 	  logical :: slow_ice_PE       ! If true, slow ice processes 

  call ice_model_restart(Ice=Ice)				  call ice_model_restart(Ice=Ice)

  !--- release memory ---------------------------------------	  !--- release memory ---------------------------------------

  fast_ice_PE = associated(Ice%fCS)				  fast_ice_PE = associated(Ice%fCS)
  slow_ice_PE = associated(Ice%sCS)				  slow_ice_PE = associated(Ice%sCS)

  if (fast_ice_PE) then						  if (fast_ice_PE) then
    call SIS_fast_thermo_end(Ice%fCS%fast_thermo_CSp)		    call SIS_fast_thermo_end(Ice%fCS%fast_thermo_CSp)

    call SIS_optics_end(Ice%fCS%optics_CSp)			    call SIS_optics_end(Ice%fCS%optics_CSp)

    if (Ice%fCS%Rad%add_diurnal_sw .or. Ice%fCS%Rad%do_sun_an	    if (Ice%fCS%Rad%add_diurnal_sw .or. Ice%fCS%Rad%do_sun_an
      call astronomy_end					      call astronomy_end

    call dealloc_ice_rad(Ice%fCS%Rad)				    call dealloc_ice_rad(Ice%fCS%Rad)
    call dealloc_total_sfc_flux(Ice%fCS%TSF)			    call dealloc_total_sfc_flux(Ice%fCS%TSF)
    call ice_grid_end(Ice%fCS%IG)				    call ice_grid_end(Ice%fCS%IG)

    if (.not.associated(Ice%sCS)) then				    if (.not.associated(Ice%sCS)) then
      call dealloc_IST_arrays(Ice%fCS%IST)			      call dealloc_IST_arrays(Ice%fCS%IST)
      deallocate(Ice%fCS%IST)					      deallocate(Ice%fCS%IST)

      call dealloc_fast_ice_avg(Ice%fCS%FIA)			      call dealloc_fast_ice_avg(Ice%fCS%FIA)
      call dealloc_simple_OSS(Ice%fCS%sOSS)			      call dealloc_simple_OSS(Ice%fCS%sOSS)
      call SIS_hor_grid_end(Ice%fCS%G)				      call SIS_hor_grid_end(Ice%fCS%G)
    else							    else
      if (.not.associated(Ice%fCS%IST,Ice%sCS%IST)) then	      if (.not.associated(Ice%fCS%IST,Ice%sCS%IST)) then
        call dealloc_IST_arrays(Ice%fCS%IST)			        call dealloc_IST_arrays(Ice%fCS%IST)
        deallocate(Ice%fCS%IST)					        deallocate(Ice%fCS%IST)
      endif							      endif
      if (.not.associated(Ice%fCS%FIA,Ice%sCS%FIA)) &		      if (.not.associated(Ice%fCS%FIA,Ice%sCS%FIA)) &
        call dealloc_fast_ice_avg(Ice%fCS%FIA)			        call dealloc_fast_ice_avg(Ice%fCS%FIA)
      if (.not.associated(Ice%fCS%sOSS,Ice%sCS%sOSS)) &		      if (.not.associated(Ice%fCS%sOSS,Ice%sCS%sOSS)) &
        call dealloc_simple_OSS(Ice%fCS%sOSS)			        call dealloc_simple_OSS(Ice%fCS%sOSS)
      if (.not.associated(Ice%fCS%G,Ice%sCS%G)) &		      if (.not.associated(Ice%fCS%G,Ice%sCS%G)) &
        call SIS_hor_grid_end(Ice%fCS%G)			        call SIS_hor_grid_end(Ice%fCS%G)
    endif							    endif

    if (associated(Ice%Ice_fast_restart) .and. &		    if (associated(Ice%Ice_fast_restart) .and. &
        (.not.associated(Ice%Ice_fast_restart, Ice%Ice_restar	        (.not.associated(Ice%Ice_fast_restart, Ice%Ice_restar
      deallocate(Ice%Ice_fast_restart)				      deallocate(Ice%Ice_fast_restart)

  endif								  endif

  if (slow_ice_PE) then						  if (slow_ice_PE) then

    if (associated(Ice%sCS%dyn_trans_CSp)) &			    if (associated(Ice%sCS%dyn_trans_CSp)) &
      call SIS_dyn_trans_end(Ice%sCS%dyn_trans_CSp)		      call SIS_dyn_trans_end(Ice%sCS%dyn_trans_CSp)

    if (associated(Ice%sCS%specified_ice_CSp)) &		    if (associated(Ice%sCS%specified_ice_CSp)) &
      call specified_ice_end(Ice%sCS%specified_ice_CSp)		      call specified_ice_end(Ice%sCS%specified_ice_CSp)

    call SIS_slow_thermo_end(Ice%sCS%slow_thermo_CSp)		    call SIS_slow_thermo_end(Ice%sCS%slow_thermo_CSp)

    call ice_thermo_end(Ice%sCS%IST%ITV)			    call ice_thermo_end(Ice%sCS%IST%ITV)

    ! End icebergs						    ! End icebergs
    if (Ice%sCS%do_icebergs) call icebergs_end(Ice%icebergs)	    if (Ice%sCS%do_icebergs) call icebergs_end(Ice%icebergs)

    call SIS_tracer_flow_control_end(Ice%sCS%SIS_tracer_flow_	    call SIS_tracer_flow_control_end(Ice%sCS%SIS_tracer_flow_

    call dealloc_ice_ocean_flux(Ice%sCS%IOF)			    call dealloc_ice_ocean_flux(Ice%sCS%IOF)

    if (Ice%sCS%redo_fast_update) then				    if (Ice%sCS%redo_fast_update) then
      call SIS_fast_thermo_end(Ice%sCS%fast_thermo_CSp)		      call SIS_fast_thermo_end(Ice%sCS%fast_thermo_CSp)
      call SIS_optics_end(Ice%sCS%optics_CSp)			      call SIS_optics_end(Ice%sCS%optics_CSp)

      call dealloc_total_sfc_flux(Ice%sCS%TSF)			      call dealloc_total_sfc_flux(Ice%sCS%TSF)
      call dealloc_total_sfc_flux(Ice%sCS%XSF)			      call dealloc_total_sfc_flux(Ice%sCS%XSF)
      call dealloc_ice_rad(Ice%sCS%Rad)				      call dealloc_ice_rad(Ice%sCS%Rad)
    endif							    endif

    call dealloc_ocean_sfc_state(Ice%sCS%OSS)			    call dealloc_ocean_sfc_state(Ice%sCS%OSS)

    call dealloc_simple_OSS(Ice%sCS%sOSS)			    call dealloc_simple_OSS(Ice%sCS%sOSS)

    call ice_grid_end(Ice%sCS%IG)				    call ice_grid_end(Ice%sCS%IG)

    call dealloc_IST_arrays(Ice%sCS%IST)			    call dealloc_IST_arrays(Ice%sCS%IST)
    deallocate(Ice%sCS%IST)					    deallocate(Ice%sCS%IST)

    call dealloc_fast_ice_avg(Ice%sCS%FIA)			    call dealloc_fast_ice_avg(Ice%sCS%FIA)

    call SIS_hor_grid_end(Ice%sCS%G)				    call SIS_hor_grid_end(Ice%sCS%G)
  endif								  endif

  call dealloc_Ice_arrays(Ice)					  call dealloc_Ice_arrays(Ice)

  if (associated(Ice%Ice_restart)) deallocate(Ice%Ice_restart	  if (associated(Ice%Ice_restart)) deallocate(Ice%Ice_restart

  if (slow_ice_PE) then						  if (slow_ice_PE) then
    call SIS_diag_mediator_end(Ice%sCS%Time, Ice%sCS%diag)	    call SIS_diag_mediator_end(Ice%sCS%Time, Ice%sCS%diag)
  else								  else
    call SIS_diag_mediator_end(Ice%fCS%Time, Ice%fCS%diag)	    call SIS_diag_mediator_end(Ice%fCS%Time, Ice%fCS%diag)
  endif								  endif

  if (associated(Ice%fCS)) deallocate(Ice%fCS)			  if (associated(Ice%fCS)) deallocate(Ice%fCS)
  if (associated(Ice%sCS)) deallocate(Ice%sCS)			  if (associated(Ice%sCS)) deallocate(Ice%sCS)

end subroutine ice_model_end					end subroutine ice_model_end

end module ice_model_mod					end module ice_model_mod
